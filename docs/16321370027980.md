# OC面试整理
[TOC]
## 自定义对象怎么实现拷贝功能

** 自定义对象的copy、mutableCopy **
- 首先，自定义对象需要遵守NSCopying和NSMutableCopying协议
- 然后需要分别实现 copyWithZone 和 mutableCopyWithZone 方法
- 如果自定义对象里的属性也是自定义对象的，那么同样也要实现上述两步

```Objective - c 
#import "person.h"

@interface person()<NSCopying, NSMutableCopying>

@end

@implementation person

- (nonnull id)copyWithZone:(nullable NSZone *)zone {
    NSLog(@"copy");
    person *test = [person allocWithZone:zone];
    test.name = [self.name copy];
    test.id = _id;
    return test;
}

- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone {
    NSLog(@"mutableCopy");
    person *test = [person allocWithZone:zone];
    test.name = [self.name mutableCopy];
    test.id = _id;
    return test;
}

@end
```

** 注意 **
自定义对象的copy 和 mutableCopy方法都是深拷贝，而对象里的属性到底是浅拷贝还是参考白，主要取决于改属性的类型，已经调用的是copy方法还是mutableCopy方法，比如属性是NSString类型，调用了copy方法是，那么就是浅拷贝。

copy方法和mutableCopy方法都不是遵守消息传递的，如果该类没有实现这两个方法，然后在外面调用了copy或者mutableCopy方法，就会崩溃。

## 对于weak属性的理解
weak属性 - 我们理解为非拥有关系。为这种属性赋新值时，设置方法既不保留新值，也不释放旧值。

** 既不保留新值，也不释放旧值 **
可以理解为：self以weak指针指向对象，该对象的初始值是A，后重新赋值为了B，那么不保留新值时，对象不会强引用着B，不释放旧值的意思是：改对象被重新赋值为了B，对A是没有影响的，因为本身不存在引用，所以也就没有释放。

当我们从xib或者storyboard中拖出控件View到工程文件里，我们会发现这个View会被声明为weak属性。

** 声明为weak属性的view不是会立马被释放的吗？那为什么还是会声明为weak属性的呢？ **
当我们拖控件进入xib或者storyboard时，这时就相当于执行了addSubview这个方法，说明此控件已经成为了根view的子控件了，那么根view在管理子控件时，是将所有的子控件统一放进subViews数组里的，如下：

```Objective - c
@property(nonatomic,readonly,copy) NSArray<__kindof UIView *> *subviews;
```

subviews数组是声明为copy属性了，所以相当于根View对subviews有了一个强引用，因此拖出来的子控件view声明为weak属性是没有问题的。

** 既然这样，那么将拖出来的子控件属性改为strong吗？ **
答案是可以的，改为strong，相当于多了一个引用，引用计数从1变为2而已。

** 那weak属性是怎么实现的呢？ **
Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个哈希表，Key是所指对象的地址，Value是一个数组，存储的是weak指针的地址。（比如：A弱引用着B，那么在weak表里面，Key就是B的地址，Value就是包含A在内的地址数组）

** 实现原理可以概括为以下三步 **
1.初始化时，runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址
2.添加引用时，objc_initWeak函数会调用objc_storeWeak()函数，objc_storeWeak()函数的作用是指针重定向，创建对应的弱引用表。（比如：先初始化一个weak变量A，这时objc_initWeak就是初始化一个weak指针指向A的地址，然后对象B捕获了A，相当于B弱引用了A，这是objc_initWeak就会调用objc_storeWeak()函数，改变weak指针的指向，变为从B指向A）
3.释放时，调用clearDeallocating函数。clearDeallocating函数首先会根据对象地址获取到weak表里的所有weak指针的数组，然后遍历这个数组把其中的数组都置为nil，最后还将这个表项从weak表中删除。

## @synthesize 和 @danamic 的区别
** @property **
@property 声明的属性 会自动生成 setter方法、getter方法、实例变量

** @synthesize **
@property声明的属性，我们可以重写它的setter方法或者getter方法，但是我们不能同时都重写他们的setter和getter方法
而如果将** @property **声明的属性加上** @synthesize **修饰，那么我们可以同时重学属性的setter方法和getter方法

** @dynamic **
在** @property ** 声明的属性下，再用** dynamic **修饰，这是在告诉编译器不需要帮此属性生成setter和getter方法，需要我们手动去实现，如果没有实现，在运行时是会崩溃的。而且** @dynamic **声明之后，不仅需要手动实现setter方法和getter方法，如果需要实例变量，也是需要我们自己去补全的。

## 动态绑定
在OC中动态绑定是用** Runtime ** 实现的。

我们知道在分类中是无法添加属性的，那如果我们不想继承这个类，但还想为这个类添加新属性的话，我们可以利用** Runtime ** 动态绑定来实现。

** Runtime的动态绑定 **
其实相当于重写属性的setter方法和getter方法
在setter方法里，调用objc_setAssociatedObject,
在getter方法里，调用objc_getAssociatedObject。
这两个方法是根据一个Key关键字去找到对应的数据的。

``` Objective - c
//ViewController+Objc.m文件
#import "ViewController+Objc.h"
#import <objc/runtime.h>

static NSString * const themeKey = @"theme_key";

@implementation ViewController (Objc)

- (NSString *)themeText {
    return (NSString *)objc_getAssociatedObject(self, &themeKey);
}

- (void)setThemeText:(NSString *)themeText {
    objc_setAssociatedObject(self, &themeKey, themeText, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
```

## Category、Extension和继承
** Category **
Category，术语称为类别，类别的用处还是很大的，主要总结为以下两点：
1.在一个类上新增方法，但是又不想继承这个类，那么就可以用到类别Category，类别允许我们在不继承类的情况下给该类新增方法，但是不可以新增属性。
2.如果想要复写原类中的一个方法，那么我们可以在类别中新增同名的方法，那么调用的时候只会调用类别实现的方法，类别的优先级是比原类要高的。

** Category 和 Extension 区别 **
1.形式上，Extension是匿名的Category
2.Extension里声明的方法需要在main implementation中实现，而Category中不作要求
3.Extension可以添加属性，Category上是不可以的
4.Category和原有类的耦合度更低一些，声明和实现都可以写在单独的文件里，但就是只能为已定义类增加Method，而不能加入实例变量
5.使用Extension可以更好的封装类，在.h文件中能看到的都是对外的接口，其余的实例变量和对内的@property等都可以写在Extension里，这样类的结构更加清晰。


