# OC知识点整理
[TOC]

## Foundation
### nil、NIL、NULL、NSNULL有什么区别
- nil是OC对象的空指针
- NIL是OC类的空指针
- NULL是C类型的空指针
- NSNULL是数值类的空对象

### 如何实现一个线程安全的 NSMutableArray?
NSMutableArray是线程不安全的，当有多个线程同时对数组进行访问和修改的时候可能会导致崩溃或数据错乱。那么为了实现一个线程安全的NSMutableArray，可以参考以下两个做法：
1. 线程锁：使用线程锁对数组进行读写时进行加锁
    1. 每对数组进行访问和操作都要进行加锁，加锁过于频繁。
2. 派发队列：每次对数组进行访问和修改操作都要进行加锁，加锁代码过于频繁，而且如果忘记加锁，可能会造成线程不安全问题。那么为了解决加锁代码频繁以及避免忘记加锁的问题，我们可以尝试在类的内部利用派发队列进行加锁。
    1. 由于NSMutableArray内部方法是闭源的，我们不能直接修改内部代码，那么我们可以新建一个类，向外部提供 NSMutableArray 实现的所有方法（在.h文件进行方法声明），而且在.m文件实现消息转发中的消息重定向方法。那么当调用某个方法，比如addObject，那么就会直接走到消息重定向，在里面利用派发队列进行加锁，重定向到NSMutableArray，那么这就可以避免了加锁频繁的问题了。
    2. 派发队列的实现细则：
        1. 创建一个自定义的并发队列或者串行队列
        2. 对于数组的没有返回值的方法，比如addObject方法等，在`dispatch_barrier_async`Block里进行重定向
        3. 对于数组有返回的方法，比如count等方法，在`dispatch_barrier_sync`Block里进行重定向
    3. 除了利用重定向外，还可以实现数组的每个方法，在方法的实现利用派发队列以及栅栏来实现线程安全
    [学习链接🔗1](https://juejin.cn/post/6844903555233480712#comment)
    [学习链接🔗2](https://www.jianshu.com/p/4195209e4d8e)
    
### atomic 修饰的属性是绝对安全的吗？为什么？
atomic修饰的属性不是绝对安全，atomic只是保证属性的存取方法是线程安全的，并不能保证整个对象是线程安全，当同时有多个线程调用对象的set和get方法，那么可能会出现数据错误的问题，或者有一个线程对属性进行了release，那么就有可能会出现crash。

### 关于isEqual与hash方法解析
#### isEqual方法
isEqual方法作用在于比较两个对象是否相等，它与==方法的区别在于：
1. 对于基本类型，==运算符比较的是值是否相等，对于对象类型，==运算符比较的是两个对象的内存地址是否一样
2. isEqual方法比较的是两个对象是否相等。具体到两个对象是否为同一类型，对象的每个属性是否也相等。

重写自己的isEqual方法
1. 利用==运算符判断是否为同一对象
2. 判断是否为同一个类型
3. 对每个属性分别比较值是否相同
4. 返回结果

举个栗子🌰
``` Objective-c
@interface Person : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, strong) NSDate *birthday;

@end

- (BOOL)isEqual:(id)object {
    if (self == object) {
        return YES;
    }
    
    if (![object isKindOfClass:[Person class]]) {
        return NO;
    }
    
    return [self isEqualToPerson:(Person *)object];
}

- (BOOL)isEqualToPerson:(Person *)person {
    if (!person) {
        return NO;
    }
    
    BOOL haveEqualNames = (!self.name && !person.name) || [self.name isEqualToString:person.name];
    BOOL haveEqualBirthdays = (!self.birthday && !person.birthday) || [self.birthday isEqualToDate:person.birthday];
    
    return haveEqualNames && haveEqualBirthdays;
}
```

#### 关于hash方法
##### 为什么要有hash方法
这个问题要从Hash Table这种数据结构说起

首先我们看下如何在数组中查找某个成员
Step 1: 遍历数组中的成员
Step 2: 将取出的值与目标值比较, 如果相等, 则返回该成员
在数组未排序的情况下, 查找的时间复杂度是O(array_length)

为了提高查找的速度, Hash Table出现了
当成员被加入到Hash Table中时, 会给它分配一个hash值, 以标识该成员在集合中的位置
通过这个位置标识可以将查找的时间复杂度优化到O(1), 当然如果多个成员都是同一个位置标识, 那么查找就不能达到O(1)了

分配的这个hash值(即用于查找集合中成员的位置标识), 就是通过hash方法计算得来的, 且hash方法返回的hash值最好唯一

和数组相比, 基于hash值索引的Hash Table查找某个成员的过程就是
- Step 1: 通过hash值直接找到查找目标的位置
- Step 2: 如果目标位置上有多个相同hash值得成员, 此时再按照数组方式进行查找

##### hash方法的调用时机
基于hash值索引实现的数据结构有NSSet和NSDictionary等，当对象被添加到NSSet和设置为NSDictionary的key时会调用hash方法，为该对象分配一个hash值。
- NSSet添加新成员时, 需要根据hash值来快速查找成员, 以保证集合中是否已经存在该成员
- NSDictionary在查找key时, 也利用了key的hash值来提高查找的效率
- 注意⚠️：字典的`setValue forKey`方法是不会调用hash方法的，只有`setObject forKey`才会调用hash方法。


```Objective-c
//setObject方法的key为id 对象类型，因此要调用hash方法，根据它的hash值作为key；而且setObject方法的key是要遵守NSCopying协议的。
//setValue方法的key为NSString *类型，不会调用hash方法的，直接利用该值作为key
- (void)setObject:(ObjectType)anObject forKey:(KeyType <NSCopying>)aKey;
- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;
```

##### hash方法与判等的关系?
hash方法主要是用于在Hash Table查询成员用的, 那么和我们要讨论的isEqual()有什么关系呢?

为了优化判等的效率, 基于hash的NSSet和NSDictionary在判断成员是否相等时, 会这样做
- Step 1: 集成成员的hash值是否和目标hash值相等, 如果相同进入Step 2, 如果不等, 直接判断不相等
- Step 2: hash值相同(即Step 1)的情况下, 再进行对象判等, 作为判等的结果

##### 如何重写自己的hash方法?
很多人在iOS开发中, 都是这么重写hash方法的
``` Objective-c
- (NSUInteger)hash {
    return [super hash];
}
```
这样写有问题么? 带着这个问题, 我们先来看下[super hash]的值到底是什么
``` Objective-c
Person *person = [[Person alloc] init];
NSLog(@"person = %ld", (NSUInteger)person);
NSLog(@"[person1 getSuperHash] = %ld", [person getSuperHash]);
```
打印结果如下
``` Objective-c
person = 140643147498880
[person1 getSuperHash] = 140643147498880
```
由此可以看出, [super hash]返回的就是该对象的内存地址

联想到前面对hash值唯一性的要求, 使用对象的内存地址作为hash值不是很好么?

别急, 我们添加如下两个对象到NSSet中试试
``` Objective-c
Person *person1 = [Person personWithName:kName1 birthday:self.date1];
Person *person2 = [Person personWithName:kName1 birthday:self.date1];
NSLog(@"[person1 isEqual:person2] = %@", [person1 isEqual:person2] ? @"YES" : @"NO");

NSMutableSet *set = [NSMutableSet set];
[set addObject:person1];
[set addObject:person2];
NSLog(@"set count = %ld", set.count);
```
此时打印结果如下
``` Objective-c
[person1 isEqual:person2] = YES
set count = 2
```
isEqual相等的两个对象都加入到了NSSet中(set count = 2), 所以直接返回[super hash]是不正确的。简单来说，如果hash方法是返回对象的内存地址，那么set在判断时就会任务两个对象是不一样的，但实质上两个对象是相等的，因此hash方法直接返回对象的内存地址是不对的。

那么hash方法的最佳实践到底是什么呢?
In reality, a simple XOR over the hash values of critical properties is sufficient 99% of the time(对关键属性的hash值进行位或运算作为hash值)

举个🌰
```Objective-c
- (NSUInteger)hash {
    return [self.name hash] ^ [self.birthday hash];
}
```
[学习链接🔗](https://www.jianshu.com/p/915356e280fc)

### id 和 instanceType 有什么区别？
相同点
1. instancetype 和 id 都是万能指针，指向对象。
不同点：
1. id类型在编译的时候不会判断对象的真实类型；instanceType在编译的时候就会判断对象的真实类型。
2. id可以用来定义变量，可以作为函数的返回值，可以作为形参；instanceType只能用于作为返回值。

### self和super的区别
1. self调用自己方法，super调用父类方法
2. self是类，super是预编译指令
3. [self class] 和 [super class] 输出是一样的
4. self和super底层实现原理
    1. 当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找，然后调用父类的这个方法
    2. 当使用 self 调用时，会使用 objc_msgSend 函数：`id objc_msgSend(id theReceiver, SEL theSelector, ...)`第一个参数是消息接收者，第二个参数是调用的具体类方法的 selector，后面是 selector 方法的可变参数。以 [self setName:] 为例，编译器会替换成调用 objc_msgSend 的函数调用，其中 theReceiver 是 self，theSelector 是 @selector(setName:)，这个 selector 是从当前 self 的 class 的方法列表开始找的 setName，当找到后把对应的 selector 传递过去。
    3. 当使用 super 调用时，会使用 objc_msgSendSuper 函数：`id objc_msgSendSuper(struct objc_super *super, SEL op, ...)`，第一个参数是个objc_super的结构体，第二个参数还是类似上面的类方法的selector

    
```C
struct objc_super {
	id receiver;
	Class superClass;
};
```
- objc中super是编译器标示符，并不像self一样是一个对象，(super是预编译指令)，遇到向super发的方法时会转译成objc_msgSendSuper(...)，而参数中的对象还是self，于是从父类开始沿继承链寻找- class这个方法，最后在NSObject中找到（若无override），此时，[self class]和[super class]已经等价了。
- super 的含义，消息转发会调用 objc_msgSendSuper， 就是 去父类的方法列表中找到 initWithFrame:这个方法，然后调用，调用的主体是 self。super 只是一个编译器的特殊字符，并不代表父类的一个实例化对象。这也就能明白为什么 调用 [super initWithFrame:frame]能得到本类的 实例化对象了，而不是父类的对象了。[self class] [super class]，class 这个方法都是 在 NSObject 对象中找到的，所以 都相当于 调用  [self class], 输入都是 一样的 SubView

### @synthesize和@dynamic分别有什么作用？
- @synthesize 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。
- @dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成，而且不会自动创建对应的成员变量（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

在@dynamic情况下实现存取方法
1. 接注释掉@dynamic name这行代码即可，由编译器自动添加。
2. 手动添加，由于@dynamic不能像@synthesize那样向实现文件(.m)提供实例变量，所以我们需要在类中显式提供实例变量。
3. 通过runtime机制在运行时添加属性的存取方法。

### 类族
类族是一种有用的设计模式，可以隐藏抽象基类背后的实现细节。系统中存在很多类族，比如UIButton,NSArray,NSString,NSNumber等。
![](media/16321370027980/16370624162870.gif)
如上图，NSNumber的范围很大，实际上NSNumber有很多隐藏的子类，但是我们通过NSNumber的numberWith方法创建得到的不是NSNumber的实例对象，而是其子类的对象，但是我们在使用的时候不需要知道这一点，只需要知道这是一个NSNumber对象即可。

使用类族的优点：
1. 可以隐藏抽象基类背后的复杂细节，
2. 程序员不需要记住各种类型的创建对象所需要的具体类,简化开发人员开发成本,提高开发效率。
3. 使用者只需调用基类简单的方法就可以返回不同的子类实例。
使用类族的缺点：
1. 类族的一个缺点也显现出来，那就是已有的类族不好扩展（比如你想NSNumber再多支持一种情况，这个恐怕很难。好在这些系统的类库已经将大部分可能都做进去了，考虑得比较完善，通常你只是去用就可以了。）

### struct和class的区别
- swift中，类是引用类型，结构体是值类型。值类型在传递和赋值时进行复制，而引用类型则只会共同指向一个内存地址。
- 引用类型比如类是在堆上的，而值类型比如结构体是在栈上的。相比于栈上的操作，堆上的操作更加复杂耗时，所以，苹果官方推荐使用结构体，这样可以提高App运行的效率。
- class的优点：
    - 可以继承，子类可以使用父类的特性和方法
    - 一个类可以被多次引用
- struct的优先：结构较小，适用于复制操作，相比于类被多次引用更加安全，无须担心内存泄漏或者多线程冲突问题。

## UIKit
### UIView 和 CALayer 是什么关系？
1. UIView 继承 UIResponder，而 UIResponder 是响应者对象，可以对iOS 中的事件响应及传递，CALayer 没有继承自 UIResponder，继承自NSObject，所以 CALayer 不具备响应处理事件的能力。CALayer 是 QuartzCore 中的类，是一个比较底层的用来绘制内容的类，用来绘制UI
2. UIView 对 CALayer 封装属性，对 UIView 设置 frame、center、bounds 等位置信息时，其实都是UIView 对 CALayer 进一层封装，使得我们可以很方便地设置控件的位置；例如圆角、阴影等属性， UIView 就没有进一步封装，所以我们还是需要去设置 Layer 的属性来实现功能。
3. UIView 是 CALayer 的代理，UIView 持有一个 CALayer 的属性，并且是该属性的代理，用来提供一些 CALayer 运行时需要的数据，例如动画和绘制。

### CALayer的代理CALayerDelegate
每个UIView都会持有一个CALayer的属性，CALayer里的CALayerDelegate协议代理是UIView。CALayerDelegate主要包含以下5个方法
```Objective-c
@protocol CALayerDelegate <NSObject>
@optional

// 告诉代理去执行展示过程
- (void)displayLayer:(CALayer *)layer;

//Tells the delegate to implement the display process using the layer's CGContextRef.
//告诉代理利用layer的CGContextRef去执行展示过程
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;

//通知代理即将开始描绘
- (void)layerWillDraw:(CALayer *)layer
  API_AVAILABLE(macos(10.12), ios(10.0), watchos(3.0), tvos(10.0));

//告诉代理当前layer需要重新绘制会覆盖自定义子类的布局
- (void)layoutSublayersOfLayer:(CALayer *)layer;

//layer的属性发生变化时询问代理应该执行哪种action
//1.直接返回一个action - 即layer对于属性值的变化需要有什么动作
//2.返回nil，让layer去别的地方询问
//3.返回NSNull，即告诉layer不需要执行一个动作，搜索到此为止。
- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;

@end
```

### UIView绘制流程
1. UIView调用setNeedsDisplay,但是没立即进行视图的绘制工作;
2. UIView调用setNeedDisplay后,系统调用view对应layer的 setNeedsDisplay方法，给需要绘制的layer做个标记
3. 当前runloop即将结束的时候调用CALayer的display方法;
4. runloop即将结束, 开始视图的绘制流程;
![](media/16321370027980/16371510497322.jpg)

如果layer的代理实现了displayLayer方法的话，那么就会调用代理的displayLayer方法，进入异步绘制过程。
> 异步绘制大概的实现为：创建一个backing store（位图），可以理解为在这个位图上面描绘数据，然后开启子线程在位图上描述数据，描绘数据完成后切换到主线程，将位图赋值给layer的content，等待GPU的渲染。

#### 系统绘制流程
![](media/16321370027980/16371514461730.jpg)
1. CALayer内部创建一个backing store(CGContextRef)();
2. 判断layer是否有代理;
    1. 有代理:调用delegete的drawLayer:inContext, 然后在合适的实际回调代理, 在[UIView drawRect]中做一些绘制工作;
    2. `drawRect`方法：该方法具有重绘作用，重写该方法实现自定义的绘制过程。
        1. 在drawRect方法中获取上下文，然后就可以进行绘制工作。
    3. 没有代理:调用layer的drawInContext方法,
3. layer上传backingStore到GPU, 结束系统的绘制流程;
4. GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。

#### 异步绘制
个人理解为:展示界面的过程中将创建上下文和控件的绘制工作放到子线程中, 子线程将那些工作完成渲染成图片后转回主线程然后将位图展示在界面上;
异步绘制的入口在[layer.delegate displayLayer], 异步绘制过程中代理负责生成对应的位图(bitmap);然后将bitmap赋值给layer.content属性展示;

#### 调用setNeedsDisplay不是立刻绘制的原因
Core Animation 在 RunLoop 中注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件 。当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。当Oberver监听的事件到来时，回调执行函数中会遍历该全局容器里所有待处理的UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。（监听事件到来时，就会调用[CALayer display]方法，然后根据判断是否有代理实现了`displayLayer`方法，有则进入到异步绘制流程，无则进入到系统绘制流程；接下来会创建一个图形上下文（CGContextRef），将要绘制的数据内容填充到图形上下文，然后将数据赋值给layer的content属性，等待GPU的渲染，GPU渲染完成之后会将数据填充到帧缓冲区，等到下一个垂直同步信号到来时，显示器就会扫描帧缓冲区的数据并将其显示出来）

[学习链接🔗1](http://www.cocoachina.com/articles/14549)
[学习链接🔗2](https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&mid=447105405&idx=1&sn=054dc54289a98e8a39f2b9386f4f620e&scene=23&srcid=0108RhyzhXk9wUwQvnW3cmZT#rd)
### Bounds 和 Frame 的区别?
1. Frame：该view在父视图坐标系统中的位置和大小
2. Bounds：该view在自身视图坐标系统中的位置和大小，改变Bounds的位置会影响子视图的位置，改变Bounds的大小会影响当前视图的大小
#### Frame的图文解析
![-w1083](media/16321370027980/16371557761133.jpg)

#### Bounds的图文解析
设置view2的frame初始值为(0,0,30,30），在没修改view1的bounds时，view1的bounds为(0，0，300，300)，而view2的位置在确定时是参照view1的坐标系统。
![-w971](media/16321370027980/16371558367328.jpg)
- 当单纯修改view1的bounds位置为(10,10,300,300)，那么会变成，可以看到view2相比原来往左上角移动了
- 因为修改view1的bounds的位置，那么相当于修改自身的坐标系统，将坐标系统中左上角从（0，0）的位置修改为（10，10），那么相当于view1的原点往上角移动了，当view2添加到view1时，坐标原点在view1的左上角，因此view2也移动上去了。
![-w330](media/16321370027980/16371559724799.jpg)

- 当单纯修改bounds的大小时，可以发现，view2相对于view1的位置是没有改变的，因此可以得出修改bounds大小不会影响view本身的坐标系统。
- 修改bounds的大小，相当于修改了视图本身的大小，视图的中心点位置不会发生变化，相当于一种缩放的感觉，最后视图的frame位置和大小都发生了变化，
![-w882](media/16321370027980/16371561784735.jpg)

### 隐式动画
1. CALayer的属性值发生变化时，会触发动画展示从旧值到新值的变化，这叫做隐式动画。
2. UIView持有的CALayer的属性值发生变化时，是没有隐式动画的，因为CALayer属性值发生变化时，会通过代理方法`actionForLayer`，询问view是否动画改变，但是代理view返回的是null，即不需要执行一个动画。

### setNeedsDisplay 和 layoutIfNeeded 两者是什么关系？
UIView的setNeedsDisplay和setNeedsLayout两个方法都是异步执行的。而setNeedsDisplay会自动调用drawRect方法，这样可以拿到UIGraphicsGetCurrentContext进行绘制；而setNeedsLayout会默认调用layoutSubViews，给当前的视图做了标记；layoutIfNeeded 查找是否有标记，如果有标记及立刻刷新。

只有setNeedsLayout和layoutIfNeeded这二者合起来使用，才会起到立刻刷新的效果。
- setNeedsLayout方法是给当前视图添加标记
- layoutIfNeeded查看当前视图是否有标记，有则立即刷新

### 谈谈对UIResponder的理解
UIResponder类是专门用来响应用户的操作处理各种事件的，包括触摸事件(Touch Events)、运动事件(Motion Events)、远程控制事件(Remote Control Events)。我们知道UIApplication、UIView、UIViewController这几个类是直接继承自UIResponder，所以这些类都可以响应事件。当然我们自定义的继承自UIView的View以及自定义的继承自UIViewController的控制器都可以响应事件。

### loadView的作用？
loadView方法会在每次访问UIViewController的view(比如controller.view、self.view)而且view为nil时会被调用，此方法主要用来负责创建UIViewController的view(重写loadView方法，并且不需要调用[super loadView])

这里要提一下 [super loadView]，[super loadView]做了下面几件事。
1. 先判断UIViewController是否从StoryBoard中加载的，如果是从StoryBoard加载的UIViewController。那么它就会从StoryBoard当中加载的UIViewController的view，把它设置当前UIViewController的view。
2. 它会先去查找与UIViewController相关联的xib文件，通过加载xib文件来创建UIViewController的view，如果在初始化UIViewController指定了xib文件名，就会根据传入的xib文件名加载对应的xib文件，如果没有明显地传xib文件名，就会加载跟UIViewController同名的xib文件
3. 如果没有关联的xib文件，就会创建一个空白的UIView，赋值给UIViewController的view属性。

综上，在需要自定义UIViewController的view时，可以通过重写loadView方法且不需要调用[super loadView]方法。
重写loadView方法即创建我们自定义的类，那么就没有去调用[super loadView]

### 视图渲染框架
UIKit是常用的框架，显示、动画都通过CoreAnimation。CoreAnimation是核心动画，依赖于OpenGL ES做GPU渲染，CoreGraphics做CPU渲染；最底层的GraphicsHardWare是图形硬件。
![](media/16321370027980/16372497050410.jpg)

![](media/16321370027980/16372499853521.jpg)
在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。

### 使用 drawRect有什么影响？
1. drawRect 方法依赖 Core Graphics 框架来进行自定义的绘制,实现drawRect方法要创建一个寄宿图（backingstore - 图形上下文），这个寄宿图占用的内存是很大的（可以理解为绘制的图层的大小，具体到每个像素点的大小），而且要依赖CPU渲染，因此利用drawRect方法绘制图形会消耗CPU和内存资源。
2. 这个方法的调用机制也是非常特别. 当你调用 setNeedsDisplay 方法时, UIKit 将会把当前图层标记为 dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将标记为 dirty 的图层重新建立 Core Graphics 上下文,然后将内存中的数据恢复出来, 再使用 CGContextRef 进行绘制。
3. 使用drawRect方法绘制图形会大大消耗CPU和内存资源，因此，我们可以使用CAShapeLayer来替代drawRect实现图形的绘制。
    1. CAShapeLayer是CoreAnimation框架的，它是基于OpenGL ES做GPU渲染；CAShapeLayer绘制图形不需要像普通 Core Graphics 一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存，它将绘制的图形放进显存，交给GPU渲染。
    2. 渲染快速。CAShapeLayer 使用了硬件加速，绘制同一图形会比用 Core Graphics 快很多。

### keyWindow 和 delegate的window有何区别
delegate.window 程序启动时设置的window对象。

keyWindow 这个属性保存了[windows]数组中的[UIWindow]对象，该对象最近被发送了[makeKeyAndVisible]消息

一般情况下 delegate.window 和 keyWindow 是同一个对象，但不能保证keyWindow就是delegate.window，因为keyWindow会因为makeKeyAndVisible而变化，例如，程序中添加了一个悬浮窗口，这个时候keywindow就会变化。

### CADisplayLink
- CADisplayLink是一个定时器。我们在应用中创建一个新的 CADisplayLink 对象，把它添加到一个runloop中，并给它提供一个 target 和 selector 在屏幕刷新的时候调用。
- 一但 CADisplayLink 以特定的模式注册到runloop之后，每当屏幕需要刷新的时候，runloop就会调用CADisplayLink绑定的target上的selector，这时target可以读到 CADisplayLink 的每次调用的时间戳，用来准备下一帧显示需要的数据。例如一个视频应用使用时间戳来计算下一帧要显示的视频数据。在UI做动画的过程中，需要通过时间戳来计算UI对象在动画的下一帧要更新的大小等等。
- 在添加进runloop的时候我们应该选用高一些的优先级，来保证动画的平滑。可以设想一下，我们在动画的过程中，runloop被添加进来了一个高优先级的任务，那么，下一次的调用就会被暂停转而先去执行高优先级的任务，然后在接着执行CADisplayLink的调用，从而造成动画过程的卡顿，使动画不流畅。
- frameInterval属性是可读可写的NSInteger型值，标识间隔多少帧调用一次selector 方法，默认值是1，即每帧都调用一次。如果每帧都调用一次的话，对于iOS设备来说那刷新频率就是60HZ也就是每秒60次，如果将 frameInterval 设为2 那么就会两帧调用一次，也就是变成了每秒刷新30次。
- 我们通过pause属性开控制CADisplayLink的运行。当我们想结束一个CADisplayLink的时候，应该调用-(void)invalidate 从runloop中删除并删除之前绑定的 target跟selector
- 另外CADisplayLink 不能被继承。

#### CADisplayLink 与 NSTimer 有什么不同
- iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。
- NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。
- CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。

### 为什么要在主线程操作UI
在开发中，如果我们在后台线程中对UI进行操作，那么编译器就会弹出一个`runtime`错误，这时只要我们将操作UI的代码放在主线程就可以解决问题，那么为什么要在主线程操作UI呢？

#### 有三个方面的原因
1. `UIKit`本身是一个线程不安全的类，当我们查看`View`视图的子属性时，可以发现几乎都是用`nonatomic`来修饰的，而本身UI操作就会涉及到子属性值的改变，那么如果在多线程环境下进行修改，那么就会存在读写问题，而加锁的话会耗费大量资源并拖慢运行速度。
2. 另一方面，触摸事件最先是分发到`UIApplication`上的，然后由`UIApplication`再进行事件的分发。`UIApplication`是整个程序的起点，它是在主线程初始化的，那么就默认所有的用户事件都是在主线程上进行传递的，因此View的操作也就在主线程上进行。
3. 还有一方面，在视图渲染方面由于图像的渲染需要以60帧的刷新频率在屏幕上同时更新，这是由于主线程的RunLoop在驱动的，在非主线程操作UI很难保证视图的同步更新。

#### Core Animation Pipeline 流水线
当我们操作UI时
1. 系统会检测到View的图层发生了变化
2. 标记视图，将视图添加到一个全局的容器上
3. 当监听当RunLoop即将进入休眠或者退出的时候，就会遍历全局容器，将里面的视图取出开始绘制流程
4. Commit Transaction：构建视图布局，进行图像的解码与格式转换，最后将Layer递归打包发送到Render Server
5. Render Server：主要负责渲染工作，生成各种绘制指令，并在下一次VSyc信号到来时调用OpenGL进行渲染
6. GPU：GPU会等待VSyc信号的到来进行OpenGL渲染，将渲染好的数据输出到帧缓冲区，要注意的是此时帧缓冲区之前的内容已经被屏幕扫描去显示了。
7. Dispaly：下一个Vsyc信号到来，显示器就会从帧缓冲区中取出画面，并输出到屏幕上。

![](media/16321370027980/16385202114596.jpg)

[学习链接🔗](https://juejin.cn/post/6844903763011076110)

## WebView
### 说一下 JS 和 OC 互相调用的几种方式？
一般都是在本地工程文件里新建了一个html文件，JS和OC互相调用其实就是当前webView展示的是html文件，在html文件里主动调用OC方法，或者利用OC调用了html文件的里js方法。

JS调用OC
- html文件内发出请求，在UIWebView的代理方法里对当前页面发出的url请求进行拦截。
- 在OC中获取当前JS的上下文 JSContext，在JS上下文里定义好JS执行的方法
- WKuserContentController 是WebKit框架里专门用来跟JS交互的类，调用这个类的`addScriptMessageHandler`方法，注册JS调用的方法，当JS调用了已经被注册的方法后，会在代理方法`- (void)userContentController:(WKUserContentController *)userContentController 
      didReceiveScriptMessage:(WKScriptMessage *)message;`里拦截到JS调用的方法

OC调用JS
- 利用webView来调用`- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;`方法；script即要调用的js方法
- 利用JSContext 调用`- (JSValue *)evaluateScript:(NSString *)script;`方法来调用JS方法
- WKWebView主动调用`- (void)evaluateJavaScript:(NSString *)javaScriptString 
         completionHandler:(void (^)(id, NSError *error))completionHandler;`方法，其中的javaScriptString就是JS的方法。

[测试demo](/Users/macbookpro/Downloads/JS_OC-master )
[学习链接🔗1](https://cloud.tencent.com/developer/article/1192332)
[学习链接🔗2](https://blog.csdn.net/zjpjay/article/details/103310279)
[学习链接🔗3](https://cloud.tencent.com/developer/article/1144981)

### 在使用 WKWedView 时遇到过哪些问题
白屏问题，Cookie 问题，在WKWebView上直接使用NSURLProtocol无法拦截请求，在WKWebView 上通过loadRequ发起的post请求body数据被丢失，截屏问题等
- 白屏问题：
    - 首先我们要知道产生白屏的原因：WKWebView之所以有更低的内存占用，是因为它是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行（也就是说使用WKWebView总的内存占用不一定比UIWebView少，只是App Process Memory会减少）。在UIWebView上，当内存占用过大，当前APP会crash，而使用WKWebView，WebContent Process会crash，这个时候就产生了白屏。
- Cookie问题：
    - WKWebView会将cookie延迟存储进NSHTTPCookieStorage，但是WKWebView发起的请求不会自动带上NSHTTPCookieStorage中的cookie。

- 页面样式问题
    - 在 WKWebView 适配过程中，我们发现部分H5页面元素位置向下偏移或被拉伸变形，追踪后发现主要是H5页面高度值异常导致：

[学习链接🔗](https://www.jianshu.com/p/182092592d8b)


### UIWebView 与 WKWebView
UIWebView 是 iOS 2 中推出的网页容器，UIWebView是最占内存的控件；直到 iOS 8 以后，苹果推出了 WebKit 框架，其中 WKWebView 正式被推出来接替 UIWebView 的位置；iOS 12 中，苹果正式弃用 UIWebView，要求开发者用 WKWebView 全面替换 UIWebView。

UIWebView 特点：
1. 加载速度慢
2. 内存占用大，App停留在后台很容易被系统杀死
3. 原生容器完全不带进度条，需要自定义开发

WKWebView 特点
1. 在性能、稳定性、功能方面有很大提升（最直观的提升就是加载网页是占用的内存很少,测试加载不同网页其内存性能提升3倍到4倍,而且没有缓存）
2. 允许JavaScript的Nitro库加载并使用（UIWebView中限制）
3. 支持更多的 HTML5 特性
4. 与 Safari 具有相同的 JavaScript 引擎

## 内存管理
### 什么情况使用weak关键字，相比assign有什么不同？
什么情况下使用weak关键字
- 在 ARC 中，在有可能出现循环引用的时候，往往要通过让其中一端使用 weak 来解决，比如: delegate、block。
- 自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。

相比于assign有什么相同点
- weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似

相比于assign有什么不同
- weak、assign 修饰的属性指向一个对象时都不会增加对象的引用计数。然而在所指的对象被释放时，weak 属性值会被置为 nil，而 assign 属性不会。
- assign 可以用于 OC 对象以及基本类型，而 weak 必须用于 OC 对象。

### 如何让自己的类用copy修饰符？如何重写带copy关键字的setter？
若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。

具体步骤：
- 首先，自定义对象需要遵守NSCopying和NSMutableCopying协议
- 然后需要分别实现 copyWithZone 和 mutableCopyWithZone 方法
- 如果自定义对象里的属性也是自定义对象的，那么同样也要实现上述两步

注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是 “copyWithZone” 方法。

举个🌰
```Objective - c 
#import "person.h"

@interface person()<NSCopying, NSMutableCopying>

@end

@implementation person

- (nonnull id)copyWithZone:(nullable NSZone *)zone {
    NSLog(@"copy");
    person *test = [person allocWithZone:zone];
    test.name = [self.name copy];
    test.id = _id;
    return test;
}

- (nonnull id)mutableCopyWithZone:(nullable NSZone *)zone {
    NSLog(@"mutableCopy");
    person *test = [person allocWithZone:zone];
    test.name = [self.name mutableCopy];
    test.id = _id;
    return test;
}

@end
```

自定义对象的copy 和 mutableCopy方法都是深拷贝，而对象里的属性到底是浅拷贝还是深拷贝，主要取决于属性的类型以及调用的是copy方法还是mutableCopy方法，比如属性是NSString类型，调用了copy方法，那么就是浅拷贝。

copy方法和mutableCopy方法都不是遵守消息传递的，如果该类没有实现这两个方法，然后在外面调用了copy或者mutableCopy方法，就会崩溃。

重写带 copy 关键字的 setter，例如：
```Objective-c
- (void)setName:(NSString *)name {
    //[_name release];
    _name = [name copy];
}
```

### 深拷贝与浅拷贝
浅拷贝是指针拷贝，两个指针还是指向同一块内存地址。
深拷贝是内容拷贝，但是两个指针已经不是指向同一块内存地址。
所以：浅拷贝和深拷贝的区别在于拷贝后的指针指向的地址是否相同。

- copy方法:如果是非可扩展类的对象，则是浅拷贝，返回的是不可变对象。如果是可扩展类的对象，是深拷贝，返回的是不可变对象。
    - 对于可扩展类的对象，调用copy方法，得到的新对象的指针跟原对象的指针指向的不是同一块内存地址，说明是深拷贝；对于新对象执行append方法都是会报错的，说明新对象仍然是不可变对象
    - 开发者文档里面也有提到，copy方法，对于接收者，不管是调用对象是可变的还是不可变的，返回的结果都是不可变的。
![-w655](media/16321370027980/16373963486061.jpg)

- mutableCopy方法:无论是可扩展类的对象还是不可扩展类的对象，都是深拷贝，返回的都是可变对象。
- 容器类的对象不管是调用copy方法还是mutableCopy方法，容器内的对象都是浅拷贝。

```Objective - c
NSMutableArray *mutableArray = [[NSMutableArray alloc] initWithArray:array copyItems:YES];
NSMutableArray *mutableArray = [array mutableCopy];
```
上面两个方法是有区别的。
- 第一个方式是对数组的Items的拷贝，是浅拷贝 还是 深拷贝 主要是跟 数组对象的类型有关系，数组对象是不可变，那么就是浅拷贝，数组对象是可变，那么就是深拷贝，可以理解为对数组元素调用了copy方法。
- 第二个方式：数组元素的拷贝都是浅拷贝。

### @property的本质是什么？ivar、getter、setter是如何生成并添加到这个类中的
- @property 的本质是实例变量（ivar）+存取方法（access method ＝ getter + setter）,即 @property = ivar + getter + setter;
    - “属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。
- ivar、getter、setter 是自动合成这个类中的
    - 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。在前例中，会生成两个实例变量，其名称分别为 _firstName 与 _lastName。也可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字。

### @protocol和category中如何使用@property
- 在 protocol 中使用 property 只会生成 setter 和 getter 方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
- category 使用 @property 也是只会生成 setter 和 getter 方法的声明,如果我们真的需要给 category 增加属性的实现,需要借助于运行时的两个函数：objc_setAssociatedObject和objc_getAssociatedObject

### @autoreleasePool的数据结构
- 创建一个自动释放池，其实是在创建AutoreleasePoolPage结构体，创建释放池会往page里插入一个哨兵对象作为标记，而page之间是一个双向链表的结构，通过parent和child指针链接page。
- page里的next指针指向下一个可存放 autorelease 对象地址的位置，初始化指向 begin()

#### 详细结构
自动释放池的官方文档
> 官方文档
The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. If you use the Application Kit, you therefore typically don’t have to create your own pools. If your application creates a lot of temporary autoreleased objects within the event loop, however, it may be beneficial to create “local” autorelease pools to help to minimize the peak memory footprint.
以上是苹果对自动释放池的一段介绍，其意思为：AppKit 和 UIKit 框架在事件循环(RunLoop)的每次循环开始时，在主线程创建一个自动释放池，并在每次循环结束时销毁它，在销毁时释放自动释放池中的所有autorelease对象。通常情况下我们不需要手动创建自动释放池，但是如果我们在循环中创建了很多临时的autorelease对象，则手动创建自动释放池来管理这些对象可以很大程度地减少内存峰值。

接下来进行自动释放池的原理分析
新建一个macOS文件，同时创建一个自动释放池
```Objective-c
int main(int argc, const char * argv[]) {
    @autoreleasepool {}
    return 0;
}
```
通过 Clang clang -rewrite-objc main.m 将以上代码转换为 C++ 代码。
```Objective-c
struct __AtAutoreleasePool {
    __AtAutoreleasePool() {
        atautoreleasepoolobj = objc_autoreleasePoolPush();
    }
    ~__AtAutoreleasePool() {
        objc_autoreleasePoolPop(atautoreleasepoolobj);
    }
    void * atautoreleasepoolobj;
};

int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ 
    { __AtAutoreleasePool __autoreleasepool;  }
    return 0;
}
```
可以看到：
- @autoreleasepool底层是创建了一个__AtAutoreleasePool结构体对象；
- 在创建__AtAutoreleasePool结构体时会在构造函数中调用objc_autoreleasePoolPush()函数，并返回一个atautoreleasepoolobj(POOL_BOUNDARY存放的内存地址，下面会讲到)；
- 在释放__AtAutoreleasePool结构体时会在析构函数中调用objc_autoreleasePoolPop()函数，并将atautoreleasepoolobj传入。

#### AutoreleasePoolPage
下面我们进入Runtime objc4源码查看以上提到的两个函数的实现。
```Objective-c
// NSObject.mm
void * objc_autoreleasePoolPush(void)
{
    return AutoreleasePoolPage::push();
}

void objc_autoreleasePoolPop(void *ctxt)
{
    AutoreleasePoolPage::pop(ctxt);
}
```
可以得知，objc_autoreleasePoolPush()和objc_autoreleasePoolPop()两个函数其实是调用了AutoreleasePoolPage类的两个类方法push()和pop()。所以@autoreleasepool底层就是使用AutoreleasePoolPage类来实现的。

下面我们来看一下AutoreleasePoolPage类的定义：
```Objective-c
class AutoreleasePoolPage 
{
#   define EMPTY_POOL_PLACEHOLDER ((id*)1)  // EMPTY_POOL_PLACEHOLDER：表示一个空自动释放池的占位符
#   define POOL_BOUNDARY nil                // POOL_BOUNDARY：哨兵对象
    static pthread_key_t const key = AUTORELEASE_POOL_KEY;
    static uint8_t const SCRIBBLE = 0xA3;   // 用来标记已释放的对象
    static size_t const SIZE =              // 每个 Page 对象占用 4096 个字节内存
#if PROTECT_AUTORELEASEPOOL                 // PAGE_MAX_SIZE = 4096
        PAGE_MAX_SIZE;  // must be muliple of vm page size
#else
        PAGE_MAX_SIZE;  // size and alignment, power of 2
#endif
    static size_t const COUNT = SIZE / sizeof(id);  // Page 的个数

    magic_t const magic;                // 用来校验 Page 的结构是否完整
    id *next;                           // 指向下一个可存放 autorelease 对象地址的位置，初始化指向 begin()
    pthread_t const thread;             // 指向当前线程
    AutoreleasePoolPage * const parent; // 指向父结点，首结点的 parent 为 nil
    AutoreleasePoolPage *child;         // 指向子结点，尾结点的 child  为 nil
    uint32_t const depth;               // Page 的深度，从 0 开始递增
    uint32_t hiwat;
    ......
}
```
整个程序运行过程中，可能会有多个AutoreleasePoolPage对象。从它的定义可以得知：

- 自动释放池（即所有的AutoreleasePoolPage对象）是以栈为结点通过双向链表的形式组合而成；
- 自动释放池与线程一一对应；
- 每个AutoreleasePoolPage对象占用4096字节内存，其中56个字节用来存放它内部的成员变量，剩下的空间（4040个字节）用来存放autorelease对象的地址。

其内存分布图如下：
![](media/16321370027980/16374225881048.jpg)
下面我们通过源码来分析push()、pop()以及autorelease方法的实现。

#### POOL_BOUNDARY
在分析这些方法之前，先介绍一下POOL_BOUNDARY。
- POOL_BOUNDARY的前世叫做POOL_SENTINEL，称为哨兵对象或者边界对象；
- POOL_BOUNDARY用来区分不同的自动释放池，以解决自动释放池嵌套的问题；
- 每当创建一个自动释放池，就会调用push()方法将一个POOL_BOUNDARY入栈，并返回其存放的内存地址；
- 当往自动释放池中添加autorelease对象时，将autorelease对象的内存地址入栈，它们前面至少有一个POOL_BOUNDARY；
- 当销毁一个自动释放池时，会调用pop()方法并传入一个POOL_BOUNDARY，会从自动释放池中最后一个对象开始，依次给它们发送release消息，直到遇到这个POOL_BOUNDARY.

#### push
```Objective-c
    static inline void *push() 
    {
        id *dest;
        if (DebugPoolAllocation) { // 出错时进入调试状态
            // Each autorelease pool starts on a new pool page.
            dest = autoreleaseNewPage(POOL_BOUNDARY);
        } else {
            dest = autoreleaseFast(POOL_BOUNDARY);  // 传入 POOL_BOUNDARY 哨兵对象
        }
        assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);
        return dest;
    }
```
当创建一个自动释放池时，会调用push()方法。push()方法中调用了autoreleaseFast()方法并传入了POOL_BOUNDARY哨兵对象。

下面我们来看一下autoreleaseFast()方法的实现：
```Objective-c
    static inline id *autoreleaseFast(id obj)
    {
        AutoreleasePoolPage *page = hotPage();     // 新创建的未满的 Page
        if (page && !page->full()) {        // 如果当前 Page 存在且未满
            return page->add(obj);                 // 将 autorelease 对象入栈，即添加到当前 Page 中；
        } else if (page) {                  // 如果当前 Page 存在但已满
            return autoreleaseFullPage(obj, page); // 创建一个新的 Page，并将 autorelease 对象添加进去
        } else {                            // 如果当前 Page 不存在，即还没创建过 Page
            return autoreleaseNoPage(obj);         // 创建第一个 Page，并将 autorelease 对象添加进去
        }
    }
```
autoreleaseFast()中先是调用了hotPage()方法获得未满的Page，从AutoreleasePoolPage类的定义可知，每个Page的内存大小为4096个字节，每当Page满了的时候，就会创建一个新的Page。hotPage()方法就是用来获得这个新创建的未满的Page。

autoreleaseFast()在执行过程中有三种情况：

- ① 当前Page存在且未满时，通过page->add(obj)将autorelease对象入栈，即添加到当前Page中；
- ② 当前Page存在但已满时，通过autoreleaseFullPage(obj, page)创建一个新的Page，并将autorelease对象添加进去；
- ③ 当前Page不存在，即还没创建过Page，通过autoreleaseNoPage(obj)创建第一个Page，并将autorelease对象添加进去。

下面我们来看一下以上提到的三个方法的实现：
```OC
    id *add(id obj)
    {
        assert(!full());
        unprotect();
        id *ret = next;  // faster than `return next-1` because of aliasing
        *next++ = obj;
        protect();
        return ret;
    }
```
page->add(obj)其实就是将autorelease对象添加到Page中的next指针所指向的位置，并将next指针指向这个对象的下一个位置，然后将该对象的位置返回。
```OC
    static __attribute__((noinline))
    id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page)
    {
        // The hot page is full. 
        // Step to the next non-full page, adding a new page if necessary.
        // Then add the object to that page.
        assert(page == hotPage());
        assert(page->full()  ||  DebugPoolAllocation);

        do {
            if (page->child) page = page->child;
            else page = new AutoreleasePoolPage(page);
        } while (page->full());

        setHotPage(page);
        return page->add(obj);
    }
```
autoreleaseFullPage()方法中通过while循环，通过Page的child指针找到最后一个Page。

- 如果最后一个Page未满，就通过page->add(obj)将autorelease对象添加到最后一个Page中；
- 如果最后一个Page已满，就创建一个新的Page并通过page->add(obj)将autorelease对象添加进去，并将该Page设置为hotPage

```OC
    static __attribute__((noinline))
    id *autoreleaseNoPage(id obj)
    {
        // "No page" could mean no pool has been pushed
        // or an empty placeholder pool has been pushed and has no contents yet
        assert(!hotPage());

        bool pushExtraBoundary = false;
        if (haveEmptyPoolPlaceholder()) {
            // We are pushing a second pool over the empty placeholder pool
            // or pushing the first object into the empty placeholder pool.
            // Before doing that, push a pool boundary on behalf of the pool 
            // that is currently represented by the empty placeholder.
            pushExtraBoundary = true;
        }
        else if (obj != POOL_BOUNDARY  &&  DebugMissingPools) {
            // We are pushing an object with no pool in place, 
            // and no-pool debugging was requested by environment.
            _objc_inform("MISSING POOLS: (%p) Object %p of class %s "
                         "autoreleased with no pool in place - "
                         "just leaking - break on "
                         "objc_autoreleaseNoPool() to debug", 
                         pthread_self(), (void*)obj, object_getClassName(obj));
            objc_autoreleaseNoPool(obj);
            return nil;
        }
        else if (obj == POOL_BOUNDARY  &&  !DebugPoolAllocation) {
            // We are pushing a pool with no pool in place,
            // and alloc-per-pool debugging was not requested.
            // Install and return the empty pool placeholder.
            return setEmptyPoolPlaceholder();
        }

        // We are pushing an object or a non-placeholder'd pool.

        // Install the first page.
        AutoreleasePoolPage *page = new AutoreleasePoolPage(nil);
        setHotPage(page);
        
        // Push a boundary on behalf of the previously-placeholder'd pool.
        if (pushExtraBoundary) {
            page->add(POOL_BOUNDARY);
        }
        
        // Push the requested object or pool.
        return page->add(obj);
    }
```
autoreleaseNoPage()方法中会创建第一个Page。该方法会判断是否有空的自动释放池存在，如果没有会通过setEmptyPoolPlaceholder()生成一个占位符，表示一个空的自动释放池。接着创建第一个Page，设置它为hotPage。最后将一个POOL_BOUNDARY添加进Page中，并返回POOL_BOUNDARY的下一个位置。

小结： 以上就是push操作的实现，往自动释放池中添加一个POOL_BOUNDARY，并返回它存放的内存地址。接着每有一个对象调用autorelease方法，会将它的内存地址添加进自动释放池中。

#### autorelease
```OC
    static inline id autorelease(id obj)
    {
        assert(obj);
        assert(!obj->isTaggedPointer());
        id *dest __unused = autoreleaseFast(obj);
        assert(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);
        return obj;
    }
```
可以看到，调用了autorelease方法的对象，也是通过以上解析的autoreleaseFast()方法添加进Page中。

#### pop
```OC
    static inline void pop(void *token) 
    {
        AutoreleasePoolPage *page;
        id *stop;

        if (token == (void*)EMPTY_POOL_PLACEHOLDER) {
            // Popping the top-level placeholder pool.
            if (hotPage()) {
                // Pool was used. Pop its contents normally.
                // Pool pages remain allocated for re-use as usual.
                pop(coldPage()->begin());
            } else {
                // Pool was never used. Clear the placeholder.
                setHotPage(nil);
            }
            return;
        }

        page = pageForPointer(token);
        stop = (id *)token;
        if (*stop != POOL_BOUNDARY) {
            if (stop == page->begin()  &&  !page->parent) {
                // Start of coldest page may correctly not be POOL_BOUNDARY:
                // 1. top-level pool is popped, leaving the cold page in place
                // 2. an object is autoreleased with no pool
            } else {
                // Error. For bincompat purposes this is not 
                // fatal in executables built with old SDKs.
                return badPop(token);
            }
        }

        if (PrintPoolHiwat) printHiwat();

        page->releaseUntil(stop);

        // memory: delete empty children
        if (DebugPoolAllocation  &&  page->empty()) {
            // special case: delete everything during page-per-pool debugging
            AutoreleasePoolPage *parent = page->parent;
            page->kill();
            setHotPage(parent);
        } else if (DebugMissingPools  &&  page->empty()  &&  !page->parent) {
            // special case: delete everything for pop(top) 
            // when debugging missing autorelease pools
            page->kill();
            setHotPage(nil);
        } 
        else if (page->child) {
            // hysteresis: keep one empty child if page is more than half full
            if (page->lessThanHalfFull()) {
                page->child->kill();
            }
            else if (page->child->child) {
                page->child->child->kill();
            }
        }
    }
```
pop()方法的传参token即为POOL_BOUNDARY对应在Page中的地址。当销毁自动释放池时，会调用pop()方法将自动释放池中的autorelease对象全部释放（实际上是从自动释放池的中的最后一个入栈的autorelease对象开始，依次给它们发送一条release消息，直到遇到这个POOL_BOUNDARY）。pop()方法的执行过程如下：

- ① 判断token是不是EMPTY_POOL_PLACEHOLDER，是的话就清空这个自动释放池；
- ② 如果不是的话，就通过pageForPointer(token)拿到token所在的Page（自动释放池的首个Page）；
- ③ 通过page->releaseUntil(stop)将自动释放池中的autorelease对象全部释放，传参stop即为POOL_BOUNDARY的地址；
- ④ 判断当前Page是否有子Page，有的话就销毁。
pop()方法中释放autorelease对象的过程在releaseUntil()方法中，下面来看一下这个方法的实现：

```OC
  void releaseUntil(id *stop) 
    {
        // Not recursive: we don't want to blow out the stack 
        // if a thread accumulates a stupendous amount of garbage
        
        while (this->next != stop) {
            // Restart from hotPage() every time, in case -release 
            // autoreleased more objects
            AutoreleasePoolPage *page = hotPage();

            // fixme I think this `while` can be `if`, but I can't prove it
            while (page->empty()) {
                page = page->parent;
                setHotPage(page);
            }

            page->unprotect();
            id obj = *--page->next;  // next指针是指向最后一个对象的后一个位置，所以需要先减1
            memset((void*)page->next, SCRIBBLE, sizeof(*page->next));
            page->protect();

            if (obj != POOL_BOUNDARY) {
                objc_release(obj);
            }
        }

        setHotPage(this);

#if DEBUG
        // we expect any children to be completely empty
        for (AutoreleasePoolPage *page = child; page; page = page->child) {
            assert(page->empty());
        }
#endif
    }
    ```
releaseUntil()方法其实就是通过一个while循环，从最后一个入栈的autorelease对象开始，依次给它们发送一条release消息，直到遇到这个POOL_BOUNDARY。

#### AutoreleasePoolPage()
我们来看一下创建一个Page的过程。AutoreleasePoolPage()方法的参数为parentPage，新创建的Page的depth加一，next指针的初始位置指向begin，将新创建的Page的parent指针指向parentPage。将parentPage的child指针指向自己，这就形成了双向链表的结构。
```OC
    AutoreleasePoolPage(AutoreleasePoolPage *newParent) 
        : magic(), next(begin()), thread(pthread_self()),
          parent(newParent), child(nil), 
          depth(parent ? 1+parent->depth : 0), 
          hiwat(parent ? parent->hiwat : 0)
    { 
        if (parent) {
            parent->check();
            assert(!parent->child);
            parent->unprotect();
            parent->child = this;
            parent->protect();
        }
        protect();
    }
```

#### autorelease对象的释放时机
那么在iOS工程中，方法里的autorelease对象是什么时候释放的呢？有系统干预释放和手动干预释放两种情况。
- 系统干预释放是不指定@autoreleasepool，所有autorelease对象都由主线程的RunLoop创建的@autoreleasepool来管理。
- 手动干预释放就是将autorelease对象添加进我们手动创建的@autoreleasepool中。

##### 系统干预释放
> 如果你的程序使用了AppKit或UIKit框架，那么主线程的RunLoop就会在每次事件循环迭代中创建并处理@autoreleasepool。也就是说，应用程序所有autorelease对象的都是由RunLoop创建的@autoreleasepool来管理。而main()函数中的@autoreleasepool只是负责管理它的作用域中的autorelease对象。

iOS在主线程的RunLoop中注册了两个Observer
- 第1个Observer监听了kCFRunLoopEntry事件，会调用objc_autoreleasePoolPush()；
- 第2个Observer
    - ① 监听了kCFRunLoopBeforeWaiting事件，会调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()；
    - ② 监听了kCFRunLoopBeforeExit事件，会调用objc_autoreleasePoolPop()。
![](media/16321370027980/16374237192902.jpg)
所以，在iOS工程中系统干预释放的autorelease对象的释放时机是由RunLoop控制的，会在当前RunLoop每次循环结束时释放。
- kCFRunLoopEntry：在即将进入RunLoop时，会自动创建了一个__AtAutoreleasePool结构体对象，并调用objc_autoreleasePoolPush()函数。
- kCFRunLoopBeforeWaiting：在RunLoop即将休眠时，会自动销毁一个__AtAutoreleasePool对象，调用objc_autoreleasePoolPop()。然后创建一个新的__AtAutoreleasePool对象，并调用objc_autoreleasePoolPush()。
- kCFRunLoopBeforeExit，在即将退出RunLoop时，会自动销毁最后一个创建的__AtAutoreleasePool对象，并调用objc_autoreleasePoolPop()。

##### 手动干预释放
可以看到，添加进手动指定的@autoreleasepool中的autorelease对象，在@autoreleasepool大括号结束时就会释放，不受RunLoop控制。

[学习链接🔗](https://cloud.tencent.com/developer/article/1615642)

### BAD_ACCESS在什么情况下出现？
- 访问了野指针；比如对一个已经释放的对象执行了 release，访问已经释放对象的成员变量或者发消息。
- 死循环

### 使用CADisplayLink、NSTimer有什么注意点？
我们使用NSTimer或者CADisplayLink，如果不加处理直接使用系统提供的API方法，就有可能出现循环引用问题
可以使用NSProxy或者为CADisplayLink、NSTimer添加block方法解决循环引用

问题分析：
1. 控制器strong引用一个NSTimer对象，那么timer在addtarget的时候就会对self进行强引用，那么就会出现循环引用问题。
2. 如果控制器weak引用一个NSTimer对象，这样虽然没有循环引用问题，但是会出现控制器一直得不到释放的问题。
    1. 主线程下创建一个NSTimer，默认是会将timer对象添加到Runloop的，那么Runloop会对timer对象有一个强引用，timer对象又强引用着控制器，Runloop是一直运行的，那么控制器是一直不会被释放的。

解决方案：
- 使用Block的形式对self进行弱化，而且离开当前页面时要将计数器置为nil。

```Objective-c
self.timer = [NSTimer scheduledTimerWithTimeInterval:1 repeats:YES block:^(NSTimer * _Nonnull timer) {
        NSLog(@"timer 执行");
    }];
```
- 使用NSProxy代理模式；创建一个类继承自NSProxy，而且weak持有target控制器（虽然用weak修饰，但是指向的内存地址即控制器的内存地址是有效的，因此，用weak修饰是有效的），当timer调用对应方法时，就通过代理进行方法重定向到target控制器

[学习链接🔗](https://juejin.cn/post/7010245818380714015)

### iOS内存分区情况
- 栈区（Stack）
    - 由编译器自动分配释放，存放函数的参数，局部变量的值等
    - 栈是向低地址扩展的数据结构，是一块连续的内存区域
- 堆区（Heap）
    - 由程序员分配释放
    - 是向高地址扩展的数据结构，是不连续的内存区域
- 全局区
    - 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域
    - 程序结束后由系统释放
- 常量区
    - 常量字符串就是放在这里的
    - 程序结束后由系统释放
- 代码区
    - 存放函数体的二进制代码

- 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

### iOS内存管理方式
- Tagged Pointer（小对象）
    - Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate
    - Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free
    - 在内存读取上有着 3 倍的效率，创建时比以前快 106 倍
    - objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据
    - 使用 Tagged Pointer 后，指针内存储的数据变成了 Tag + Data，也就是将数据直接存储在了指针中

#### SideTables 与 SideTable 解析
> 源码解析 来自于 objc4-781。

SideTables 与 SideTable 是两种不同的数据结构。
##### SideTables
首先在源码中搜索SideTables，可以找到它的相关定义。
```C++
static objc::ExplicitInit<StripedMap<SideTable>> SideTablesMap;

static StripedMap<SideTable>& SideTables() {
    return SideTablesMap.get();
}
```
可以看出`SideTables`是`StripedMap<SideTable>`类型的数据结构；再在源码里搜索`StripedMap`，可以看到`StripedMap`是一个（void* -> T）类型的泛型映射表，在真机上StripeCount为8，而在其他平台上StripeCount为64；

那么可以得出
- `StripedMap`内部以数组的形式维护了一个长度为8的SideTable数组；
- 根据传入的对象的地址通过`indexForPointer`函数得出对应的哈希值，取出其所在的SideTable

![-w920](media/16321370027980/16376572350490.jpg)

##### SideTable
在源码里搜索`SideTable`
可以看到，`SideTable`里分别有三个成员变量
- spinlock_t slock 自旋锁，修改对象的引用计数以及weak表的时候会加锁防止多线程环境下出错。
- RefcountMap refcnts 引用计数表
- weak_table_t weak_table 弱引用表
```C++
struct SideTable {
    spinlock_t slock;
    RefcountMap refcnts;
    weak_table_t weak_table;

    SideTable() {
        memset(&weak_table, 0, sizeof(weak_table));
    }

    ~SideTable() {
        _objc_fatal("Do not delete SideTable.");
    }

    void lock() { slock.lock(); }
    void unlock() { slock.unlock(); }
    void forceReset() { slock.forceReset(); }

    // Address-ordered lock discipline for a pair of side tables.

    template<HaveOld, HaveNew>
    static void lockTwo(SideTable *lock1, SideTable *lock2);
    template<HaveOld, HaveNew>
    static void unlockTwo(SideTable *lock1, SideTable *lock2);
};
```

##### retain
在源码里搜索`retain`，一路jump，来到关键方法`objc_object::rootRetain`，我们发现`retain`方法最终调用的是`sidetable_retain()`方法
![-w895](media/16321370027980/16376578111438.jpg)

进入到`sidetable_retain()`方法，可以看到该方法的实现很简单。
1. 根据this，即对象的内存地址，访问到`SideTables`映射表维护的数组里的`SideTable`
2. 对`SideTable`进行操作时，先利用自旋锁上锁
3. 同样也是根据对象的内存地址从`SideTable`中取出引用计数表`refcntStorage`
4. `retain`操作即对数据`refcntStorage`进行加1
5. 解锁完成`retain`操作
```C++
id
objc_object::sidetable_retain()
{
#if SUPPORT_NONPOINTER_ISA
    ASSERT(!isa.nonpointer);
#endif
    SideTable& table = SideTables()[this];
    
    table.lock();
    size_t& refcntStorage = table.refcnts[this];
    if (! (refcntStorage & SIDE_TABLE_RC_PINNED)) {
        refcntStorage += SIDE_TABLE_RC_ONE;
    }
    table.unlock();

    return (id)this;
}
```

##### release
同样先在源码里搜索`release`，一路jump，最终找到关键方法`sidetable_release`
![-w823](media/16321370027980/16376581833308.jpg)
在关键方法`sidetable_release`里
可以发现，跟`retain`的操作是相似的。
1. 根据对象的内存地址从`SideTables`中找出对应的`SideTable`
2. 在`SideTable`里根据内存地址找到引用计数表
3. 根据对象的引用计数来判断该对象是否需要被释放
4. 若需要释放，则将`do_dealloc`设置为true，以及将引用计数与SIDE_TABLE_DEALLOCATING（为2），进行异或，其实得出的结果就是0
5. 若不需要释放，将引用计数 -1
![-w814](media/16321370027980/16376582907134.jpg)

[学习链接🔗1](https://www.jianshu.com/p/961efaef4610?utm_source=desktop&utm_medium=timeline)
[学习链接🔗2](https://www.jianshu.com/p/e0b03d2be843)

#### 弱引用weak 与 weak_table
> The weak table is a hash table governed by a single spin lock.
An allocated blob of memory, most often an object, but under GC any such allocation, may have its address stored in a __weak marked storage location through use of compiler generated write-barriers or hand coded uses of the register weak primitive. Associated with the registration can be a callback block for the case when one of the allocated chunks of memory is reclaimed.
The table is hashed on the address of the allocated memory. When __weak marked memory changes its reference, we count on the fact that we can still see its previous reference.
So, in the hash table, indexed by the weakly referenced item, is a list of all locations where this address is currently being stored.

以上是objc4-781版本中objc_weak.h头文件中对于weak表的定义。weak表是什么？回答这个问题我们需要联想到开发中常用的weak或者__weak修饰词。在开发中，通常在防止诸如delegate使用时的内存泄漏问题时，我们会在delegate属性定义的修饰词中使用weak来修饰它，这样子就能解决使用代理时循环引用导致内存泄漏的问题。或者，当我们有一个UI控件在交互中显示一次后就不再需要它时，我们也可以用weak来定义，这样在它被从图层上移除时就会自动置nil，减少了内存占用。但在这个机制的背后是怎样运作的，为什么被weak或者__weak修饰的对象可以自动置nil，这背后就是weak表在起作用。

通过上次对`SidesTables`的学习，可以知道在真机上`SidesTables`里面维护着一个长度为8的`SidesTable`数组，通过对象的内存地址得出对应的哈希值找出其所在的`SidesTable`，而`SidesTable`里有三个成员变量，分别是自旋锁、引用计数表、弱引用表，弱引用表就是现在要学习的`weak_table_t`

源码搜索`weak_table_t`
`weak_table_t`里有四个成员变量，分别是
- weak_entries ：这里是一个数组，维护着多个对象的弱引用入口
- num_entries：数组的大小
- mask：掩码，用来与对象的内存地址进行按位与找出弱引用的入口
- max_hash_displacement：应该计算偏移量有关
```C++
struct weak_table_t {
    weak_entry_t *weak_entries;
    size_t    num_entries;
    uintptr_t mask;
    uintptr_t max_hash_displacement;
};
```

再在源码里搜索`weak_entry_t`
除去一些方法，`weak_entry_t`结构体里主要保存以下信息
- referent：保存了对象objc_object，在寻找对象弱入口时会与该变量比对找出对应的weak_entry_t
- union：这是个联合体，联合体里面定义了两个结构体，联合体的存在说明两个结构体同一时间内只能有一个是有效的。

```C++
struct weak_entry_t {
    DisguisedPtr<objc_object> referent;
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
}
```
联合体的两个结构体里都出现了`weak_referrer_t`，我们查看一下
`typedef DisguisedPtr<objc_object *> weak_referrer_t;`
说明`weak_referrer_t`是一个数组，数组的内容是`objc_object`

那么重新回顾上面的两个结构体
- 第一个结构体里的`weak_referrer_t *referrers`是一个二维数组，里面存放的是指向这个对象的弱引用
- 第二个结构体里的`weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];`是一个一维数组，里面同样也是存放指向这个对象的弱引用
- 两者的区别就是第一个结构体的容量更大
- 联合体的作用在于：先创建一个小容量的数组来存放弱引用指针，当容量超过指定大小，那么就会去初始化大容量的二维数组，之前的一维数组就无效了。

```C++
    union {
        struct {
            weak_referrer_t *referrers;
            uintptr_t        out_of_line_ness : 2;
            uintptr_t        num_refs : PTR_MINUS_2;
            uintptr_t        mask;
            uintptr_t        max_hash_displacement;
        };
        struct {
            // out_of_line_ness field is low bits of inline_referrers[1]
            weak_referrer_t  inline_referrers[WEAK_INLINE_COUNT];
        };
    };
```

##### weak对象插入
在`NSObject.mm`文件中我们可以找到`StoreWeak`方法的实现，`StoreWeak`方法由`objc_initweak`方法调用。我们直接在源码里定位到关键方法
![-w767](media/16321370027980/16376746825075.jpg)
可以看到，在`storeweak`方法中，`weak_register_no_lock`方法是关键的将弱引用添加到`weak table`中的方法，当然在这之前还有各种必要的加锁以及其他操作。

在`weak_register_no_lock`方法里我们直接定位将弱引用插入到`weak table`的操作；
可以发现，是根据对象的所在的weak_table 以及 对象调用`weak_entry_for_referent`方法来查找`weak table`里是否已经存在该对象的弱引用入口，存在的话，往这个入口插入新的弱引用。
![-w801](media/16321370027980/16376747937353.jpg)

至此，一个weak对象已经成功地加入到了`weak table`中。通过这个过程我们可以更清晰地了解到`weak table`运作的机制，也验证了`weak table`是以object为key，weak_entry_t为value的hash table这一事实。

##### 其他的相关方法
我们在weak_table_t结构体的定义下可以看到objc_weak.h向外暴露了四个接口，分别是向weak table注册插入对象、注销移除对象、查找弱引用对象是否已在表中、将所有该object的弱引用指针置nil。
![-w790](media/16321370027980/16376751839207.jpg)

##### 弱引用置nil
直奔关键方法
可以看见，在weak table 里 找到对象的弱引用入口，遍历保存弱引用的数组，将弱引用全部置为nil，最后将弱引用入口从weak table 中删除。
![-w850](media/16321370027980/16376753655565.jpg)

##### __weak
利用__weak修饰对象obj时，就会调用前面说到的`objc_initWeak`方法进而调用`storeWeak`方法，为obj对象创建一个weak_entry，添加一个弱引用，指向obj对象
```Objective-c
        NSObject *obj = [[NSObject alloc]init];
        id __weak obj1 = obj;
```

要注意的是
- __weak修饰符适用于Block，当Block引用了外部变量时，会检查变量的修饰符，如果是__weak，那么会对它进行弱引用，默认是强引用。
- 在NSTimer初始化时，如果对addtarget参数进行弱化，其实是无效的，NSTimer不会检查target的类型，默认是强引用。

### 循环引用
循环引用的实质：多个对象相互之间有强引用，不能释放让系统回收。

如何解决循环引用？
- 避免产生循环引用，通常是将 strong 引用改为 weak 引用。
- 在合适时机去手动断开循环引用。 通常我们使用第一种。

常见的循环引用
- 代理(delegate)循环引用属于相互循环引用
    - delegate 是iOS中开发中比较常遇到的循环引用，一般在声明delegate的时候都要使用弱引用 weak,或者assign,当然怎么选择使用assign还是weak，MRC的话只能用assign，在ARC的情况下最好使用weak，因为weak修饰的变量在释放后自动指向nil，防止野指针存在
- NSTimer循环引用属于相互循环使用
    - 在控制器内，创建NSTimer作为其属性，由于定时器创建后也会强引用该控制器对象，那么该对象和定时器就相互循环引用了。 如何解决呢？ 这里我们可以使用手动断开循环引用： 如果是不重复定时器，在回调方法里将定时器invalidate并置为nil即可。 如果是重复定时器，在合适的位置将其invalidate并置为nil即可
- block循环引用
    - 由于block会对block中的对象进行持有操作,就相当于持有了其中的对象，而如果此时block中的对象又持有了该block，则会造成循环引用。 解决方案就是使用__weak修饰self即可
    - 并不是所有block都会造成循环引用。 只有被强引用了的block才会产生循环引用 而比如dispatch_async(dispatch_get_main_queue(), ^{}),[UIView animateWithDuration:1 animations:^{}]这些系统方法等 或者block并不是其属性而是临时变量,即栈block
    - 还有一种场景，在block执行开始时self对象还未被释放，而执行过程中，self被释放了，由于是用weak修饰的，那么weakSelf也被释放了，此时在block里访问weakSelf时，就可能会发生错误(向nil对象发消息并不会崩溃，但也没任何效果)。 对于这种场景，应该在block中对 对象使用__strong修饰，使得在block期间对 对象持有，block执行结束后，解除其持有。

## 消息传递的方式
### KVC实现原理
KVC，键-值编码，使用字符串直接访问对象的属性。
当调用setValye:属性值 forKey:@"name" 方法时，底层的执行机制如下：
- 程序优先调用set<Key>:属性值方法，通过setter方法完成设置。注意这里的<Key>是指成员变量名
- 如果没有找到setName:方法，KVC机制首先会检查+ (BOOL)accessInstanceVariablesDirectly方法是否返回YES（默认是返回YES的），如果重写了此方法并让其返回NO的话，那么KVC机制找不到setName:方法时就会进一步执行setValue: forUndefineKey:方法（找不到Key时在此方法里默认会抛出异常）
- 如果该类没有set<Key>：方法，也没有_<key>成员变量，KVC机制会搜索_is<Key>的成员变量。
- 如果还找不到，KVC机制会继续搜索<key>,is<Key>的成员变量，再给它们赋值。
- 如果上述的方法或者成员变量都不存在，那么系统就会执行该对象的setValue: forUndefineKey：方法，默认是抛出异常
简单来说就是 如果没有找到set<Key>方法的话，会按照_key,_isKey,key,iskey的顺序搜索成员变量进行赋值操作。

KVC取值
当调用valueForKey:@"name"的代码时，底层的执行机制如下：
- 程序优先调用Key方法；如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。
- 若没有找到，则会调用+ (BOOL)accessInstanceVariablesDirectly方法判断是否允许取成员变量的值。
- 若返回NO，直接调用- (nullable id)valueForUndefinedKey:(NSString *)key方法，默认是奔溃。
- 若返回YES,会按先后顺序取_key、_isKey、 key、isKey的值。
- 返回YES时，_key、_isKey、 key、isKey的值都没取到，调用- (nullable id)valueForUndefinedKey:(NSString *)key方法。

### KVO的实现原理
KVO是通过isa-swizzling实现的。
基本流程就是编译器自动为被观察对象创造一个派生类，并将被观察对象的isa指针指向这个派生类。如果用户注册了对此目标对象的某一个属性的观察，那么此派生类会重写这个方法，并在其中添加进行通知的代码。Objective-c在发送消息的时候，会通过isa指针找到当前对象所属的类对象，再通过类对象找到class_rw_t 结构体，里面保存着当前对象的实例方法，因此在向此对象发送消息的时候，实际上是发送到了派生类对象的方法。由于编译器对派生类的方法进行了重写，并添加了通知代码，因此会向注册的观察对象发送通知。注意的是派生类只是重写了注册了观察者的属性方法。

- 当给A类添加KVO的时候，编译器会自动为A类闯将一个派生类，并让A类的isa指针指向派生类，重写class方法，方法实现仍然返回原类
- 当注册了对类的属性进行观察时，派生类就会重写这个属性的setter方法
- 在setter方法内部分别调用了willChangeValueForKey，给属性赋值，didChangeValueForKey三个方法，didChangeValueForKey方法李会调用通知观察者的方法observeValueForKeyPath，通知属性值发生了变化。
- 重写了dealloc方法；在移除KVO观察者后，对象的isa指针由指向派生类到指向原来所属的类
派生类一旦被创建，为了后续的重用，是一直存在内存中的，不会被销毁。

### 如何手动触发KVO方法
手动KVO的话，就需要我们去关掉系统默认的对于特定keyPath的KVO通知，比如关掉age属性的KVO通知
```Objective-c
+ (BOOL) automaticallyNotifiesObserversForKey:(NSString *)key {
    if ([key isEqualToString:@"age"]) {
        return NO;
    }
    return [super automaticallyNotifiesObserversForKey:key];
}
```
然后还要在要监听的属性的setter方法里手动调用willChangeValueForKey和didChangeValueForKey两个方法，当监听的属性值发生变化时，就会自动地去通知观察者
🌰
```Objective-c
- (void) setAge:(int)theAge
{   //对age成员变量开启了手动KVO通知
    [self willChangeValueForKey:@"age"];
    age = theAge;
    [self didChangeValueForKey:@"age"];
}
```

键值观察通知依赖于 NSObject 的两个方法: willChangeValueForKey: 和 didChangeValueForKey。在一个被观察属性发生改变之前， willChangeValueForKey: 一定会被调用，这就 会记录旧的值。而当改变发生后， didChangeValueForKey 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。如果可以手动实现这些调用，就可以实现“手动触发”了 有人可能会问只调用didChangeValueForKey方法可以触发KVO方法，其实是不能的，因为willChangeValueForKey: 记录旧的值，如果不记录旧的值，那就没有改变一说了

### 通知和代理有什么区别
- 通知是观察者模式，适合一对多的场景
- 代理模式适合一对一的反向传值
- 通知监听方法不能有返回值，代理实现的方法可以有返回值
- 通知的耦合度较低，发布通知时不需要知道监听者是谁，监听者只需要知道通知的名称即可实现监听。

### block和delegate的区别
- delegate运行成本低，block的运行成本高。
    - block出栈需要将使用的数据从栈内存拷贝到堆内存，如果是对象的话就是加计数，使用完或者block置nil后才消除。delegate只是保存了一个对象指针，直接回调，没有额外消耗。就像C的函数指针，只多做了一个查表动作。
- 有多个相关方法。假如每个方法都设置一个 block, 这样会更麻烦。而 delegate 让多个方法分成一组，只需要设置一次，就可以多次回调。当多于 3 个方法时就应该优先采用 delegate。当1，2个回调时，则使用block。
- delegate更安全些，比如: 避免循环引用。使用 block 时稍微不注意就形成循环引用，导致对象释放不了。这种循环引用，一旦出现就比较难检查出来。而 delegate 的方法是分离开的，并不会引用上下文，因此会更安全些。
- delegate回调返回的参数被限制在了 NS 类的范围内，数量也很有限；当对协议定义的方法返回Int，CGFloat等基础类型时，是会报错的。

### 为什么Block用copy关键字
Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁在调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。

## 数据存储
### iOS 开发中数据持久性有哪几种?
iOS本地数据保存有多种方式,比如NSUserDefaults、归档、文件保存、数据库、CoreData、KeyChain(钥匙串)等多种方式。其中KeyChain(钥匙串)是保存到沙盒范围以外的地方，也就是与沙盒无关。

#### 归档和解档
归档：就是将对象序列化之后存储的过程
解档：对归档的数据进行解码
序列化：将对象的状态信息转换为可以存储或传输的形式的过程

实现归档和解档，对象要遵守NSCoding协议，并且重写 -initWithCoder:（归档） 和 encodeWithCoder:（解档）方法
[链接🔗](https://www.jianshu.com/p/24856243d36a)

### 关于keychain的小知识
Keychain Services 是 macOS 和 iOS 都提供一种安全的存储敏感信息的工具,比如,网络密码:用户访问服务器或者网站,通用密码:用来保存应用程序或者数据库密码.与此同时,用于认证的证书,密钥,和身份信息,也可以存储在Keychain中,Keychain Services 的安全机制保证了存储这些敏感信息不会被窃取。简单说来，Keychain 就是一个安全容器。

keychain是用SQLite进行存储的。用苹果的话来说是一个专业的数据库，加密我们保存的数据，可以通过metadata（attributes）进行高效的搜索。keychain适合保存一些比较小的数据量的数据，如果要保存大的数据，可以考虑文件的形式存储在磁盘上，在keychain里面保存解密这个文件的密钥。

![-w696](media/16321370027980/16377660128816.jpg)
如上图，每一个keyChain的组成如图,整体是一个字典结构.

- kSecClass key 定义属于哪一种类型的keyChain（通用密码、互联网密码、证书、密钥和身份）
- 不同的类型包含不同的Attributes,这些attributes定义了这个item的具体信息
- 每个item可以包含一个密码项来存储对应的密码

在macOS中，当keychain被锁的时候加密的item没办法访问，如果你想要该问被锁的item，就会弹出一个对话框，需要你输入对应keychain的密码。当然，没有密码的keychain你可以随时访问。但在iOS中，你只可以访问你自已的keychain items

#### keychain特点
- 数据并不存放在App的Sanbox中，即使删除了App，资料依然保存在keychain中。如果重新安装了app，还可以从keychain获取数据。
- keychain的数据可以通过group方式，让程序可以在App间共享。不过得要相同TeamID
- keychain的数据是经过加密的

#### 私有区和公共区
对于每一个应用来说，KeyChain都有两个访问区，私有区和公共区。私有区是一个sandbox，本程序存储的任何数据都对其他程序不可见，其他应用程序无法访问该区数据。如果要想将存储的内容放在公共区，实现多个应用程序间可以共同访问一些数据，则可以先声明公共区的名称，官方文档管这个名称叫“keychain access group”

#### 公共区的共享
在 iOS 3.0 之后，应用间共享 keychain 数据成为了一种可能。但这是被严格限制的,只有拥有相同 App ID 前缀的应用才有可能共享 keychai,并且各应用存储的 keychain item 都标记了相同的 kSecAccessGroup 字段值

1. 相同的Team ID
    1. 有相同的 Team ID这个是应用间共享 Keychain 数据的前提条件。一个 App ID 分两部分：
        1. Apple 为你生成的 Team ID
        2. 开发者注册的 Bundle ID
    2. 一个典型的 App ID 如：GPZ8FX842Q.com.apple.app, GPZ8FX842Q即为你的Team ID,是 Apple 为你生成的
    3. 一个开发者账号可以有不同的几个 Team ID。但 Apple 不会为不同的开发者生成一样的 Team ID。这样，不同的开发者账号发布的应用想共享 keychain 数据，在现在来看是无法实现的。而要做到 Keychain 数据共享，要求是同一个开发账号开发的，同时选择了相同的 Team ID

2. 打开Xcode里的Keychain Sharing权限，并配置好相关文件的权限
3. 配置好后，须用你正式的证书签名编译才可通过。否则xcode会弹框告诉你code signing有问题。所以，苹果限制了你只能同公司的产品共享KeyChain数据，别的公司访问不了你公司产品的KeyChain

[学习链接🔗](https://juejin.cn/post/6844903921765318669)

## 多线程
### iOS中的多线程
- 多线程的实现原理：事实上，同一时间内单核的CPU只能执行一个线程，多线程是CPU快速的在多个线程之间进行切换（调度），造成了多个线程同时执行的假象。
- 如果是多核CPU就真的可以同时处理多个线程了。
- 多线程的目的是为了同步完成多项任务，通过提高系统的资源利用率来提高系统的效率。
- 这里说的线程指的是内核级线程，用户级线程是用户层面的，不是CPU调度的基本单位。


### 多线程的优点和缺点
- 优点

能适当提高程序的执行效率

能适当提高资源利用率（CPU、内存利用率）

- 缺点:

开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能

线程越多，CPU在调度线程上的开销就越大

程序设计更加复杂：比如线程之间的通信、多线程的数据共享

### iOS中实现多线程的几种方案，各自有什么特点？
- NSThread： 使用面向对象，但是需要手动管理线程的生命周期
- GCD： 基于c语言的，充分利用了设备的多核，自动管理线程生命周期。比NSOperation效率更高。
- NSOperation： 基于GCD的进一步封装，更加面向对象，比GCD多了一些简单实用的功能。
![](media/16321370027980/16377694510169.png)

GCD 和 NSOperation的区别主要表现在以下几方面:
1. GCD是一套 C 语言API,执行和操作简单高效，因此NSOperation底层也通过GCD实现，这是他们之间最本质的区别.因此如果希望自定义任务，建议使用NSOperation；
2. 依赖关系，NSOperation可以设置操作之间的依赖(可以跨队列设置)，GCD无法设置依赖关系，不过可以通过同步来实现这种效果；
3. KVO(键值对观察)，NSOperation容易判断操作当前的状态(是否执行，是否取消等)，对此GCD无法通过KVO进行判断；
4. 优先级，NSOperation可以设置自身的优先级，但是优先级高的不一定先执行，GCD只能设置队列的优先级，如果要区分block任务的优先级,需要很复杂的代码才能实现；
5. 继承，NSOperation是一个抽象类.实际开发中常用的是它的两个子类:NSInvocationOperation和NSBlockOperation，同样我们可以自定义NSOperation，GCD执行任务可以自由组装，没有继承那么高的代码复用度；
6. 效率，直接使用GCD效率确实会更高效，NSOperation会多一点开销，但是通过NSOperation可以获得依赖，优先级，继承，键值对观察这些优势，相对于多的那么一点开销确实很划算，鱼和熊掌不可得兼，取舍在于开发者自己；
7. 可以随时取消准备执行的任务(已经在执行的不能取消),GCD没法停止已经加入queue 的 block(虽然也能实现,但是需要很复杂的代码)

### 多个网络请求完成后执行下一步
- 使用GCD的dispatch_group_t
每次网络请求前先dispatch_group_enter,请求回调后再dispatch_group_leave，enter和leave必须配合使用，有几次enter就要有几次leave，否则group会一直存在。

- 使用GCD的信号量dispatch_semaphore_t
    - 全部任务执行完之后进行v操作
    - 下一步之前执行p操作

    
### 多个网络请求顺序执行后执行下一步
- 使用信号量semaphore
    - 在任务执行完成之前进行P操作阻塞，任务执行完之后进行V操作

### 异步操作两组数据时, 执行完第一组之后, 才能执行第二组
这里使用dispatch_barrier_async方法即可实现

### 多线程中的死锁

死锁是由于多个线程（进程）在执行过程中，因为争夺资源而造成的互相等待现象，你可以理解为卡主了。产生死锁的必要条件有四个：

- 互斥条件 ： 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。

- 请求和保持条件 ： 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。

- 不可剥夺条件 ： 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。

- 环路等待条件 ： 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。
最常见的就是 同步函数 + 主队列 的组合，本质是队列阻塞。

### GCD执行原理
- GCD有一个底层线程池，这个池中存放的是一个个的线程。之所以称为“池”，很容易理解出这个“池”中的线程是可以重用的，当一段时间后这个线程没有被调用的话，这个线程就会被销毁。注意：开多少条线程是由底层线程池决定的（线程建议控制再3~5条），池是系统自动来维护，不需要我们程序员来维护，而我们程序员需要关心的是什么呢？我们只关心的是向队列中添加任务，队列调度即可。
- 如果队列中存放的是同步任务，则任务出队后，底层线程池中会提供一条线程供这个任务执行，任务执行完毕后这条线程再回到线程池。这样队列中的任务反复调度，因为是同步的，所以当我们用currentThread打印的时候，就是同一条线程。
- 如果队列中存放的是异步的任务，（注意异步可以开线程），当任务出队后，底层线程池会提供一个线程供任务执行，因为是异步执行，队列中的任务不需等待当前任务执行完毕就可以调度下一个任务，这时底层线程池中会再次提供一个线程供第二个任务执行，执行完毕后再回到底层线程池中。
- 这样就对线程完成一个复用，而不需要每一个任务执行都开启新的线程，也就从而节约的系统的开销，提高了效率。在iOS7.0的时候，使用GCD系统通常只能开5~8条线程，iOS8.0以后，系统可以开启很多条线程，但是实在开发应用中，建议开启线程条数：3~5条最为合理。

## 动画
### UIView动画与核心动画的区别
- 核心动画只能添加到CALayer
- 核心动画都是假象，并没有真正改变图层属性的值，展示和真实的位置不同
- 如果需要与用户交互就使用UIView的动画.
- 不需要与用户交互可以使用核心动画
- 在转场动画中，核心动画的类型比较多

### position 与 anchorPoint
- position是UIView的CALayer图层中的anchorPoint相对于父View的位置坐标
- anchorPoint是UIView的CALayer图层中的中心点相对于自身坐标系统的位置坐标，一般View的中心点即为anchorPoint，坐标为（0.5，0.5）
- 互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。

#### 修改position
可以发现
- 修改了position之后anchorPoint是不会发生改变的，验证了position只是当前View的layer的中心点相对于父视图的位置坐标。
- 修改了layer的position会影响view的位置
![-w836](media/16321370027980/16378328463359.jpg)

#### 修改anchorPoint
可以发现
- 修改anchorPoint是不会影响position的位置的，验证了两者是互不影响的
- 但是修改anchorPoint会影响到View的位置
![-w815](media/16321370027980/16378329853404.jpg)

#### 总结
- 无论是修改anchorPoint还是position，都会影响到View的位置。
- 修改position，那么view的中心点会移动到position设置的新位置处
- 修改anchorPoint，那么view的layer的中心点变化了，而且中心点会定位到position指定的位置。

## 图像处理
### 图片的压缩方式
- 压缩图片质量
    - 一般情况下使用UIImageJPEGRepresentation或UIImagePNGRepresentation方法实现。

通过以下两个方法的声明，可以看出，压缩成PNG是无损压缩的，而压缩成JPEG是有损压缩，因此压缩成JPEG后所占的内存会更加得少，而且苹果对 JPEG 有硬编码和硬解码，保存成 JPEG 会大大缩减编码解码时间，也能减小文件体积。
```Objective-c
//压缩成JPEG的方法有两个参数，一个是image引用，一个是压缩系数
NSData * UIImageJPEGRepresentation(UIImage *image, CGFloat compressionQuality);
//压缩成PNG的方法只有一个参数，只是image引用
NSData * UIImagePNGRepresentation(UIImage *image);
```
- 压缩图片尺寸和质量
    - 将image重新设置像素大小以达到压缩的目的

[学习链接🔗](https://blog.csdn.net/it_male/article/details/49612501)

### 图片加载的工作流
概括来说，从磁盘中加载一张图片，并将它显示到屏幕上，中间的主要工作流如下：

1. 假设我们使用 +imageWithContentsOfFile: 方法从磁盘中加载一张图片，此时的图片并没有解压缩；
2. 然后将生成的 UIImage 赋值给 UIImageView；
3. 接着一个隐式的 CATransaction 捕获到了 UIImageView 图层树的变化；
4. 将UIImageView添加到全局的容器里，等到Runloop即将进入休眠或者退出，取出数据进行绘制
    1. 分配内存缓冲区用于管理文件 IO 和解压缩操作；
    2. 将文件数据从磁盘读到内存中；
    3. 将压缩的图片数据解码成未压缩的位图形式，这是一个非常耗时的 CPU 操作；
    4. 最后 Core Animation 使用未压缩的位图数据渲染 UIImageView 的图层。
由上面的步骤可知，图片的解压缩是一个非常耗时的 CPU 操作，并且它默认是在主线程中执行的。那么当需要加载的图片比较多时，就会对我们应用的响应性造成严重的影响，尤其是在快速滑动的列表上，这个问题会表现得更加突出。

#### 为什么需要解压缩？
既然图片的解压缩需要消耗大量的 CPU 时间，那么我们为什么还要对图片进行解压缩呢？是否可以不经过解压缩，而直接将图片显示到屏幕上呢？答案是否定的。要想弄明白这个问题，我们首先需要知道什么是==位图==：
其实，位图就是一个像素数组，数组中的每个像素就代表着图片中的一个点。我们在应用中经常用到的 JPEG 和 PNG 图片就是位图。
> 解压缩后的图片大小(3600) = 图片的像素宽(30) * 图片的像素高(30) * 每个像素所占的字节数(4)

事实上，不管是 JPEG 还是 PNG 图片，都是一种压缩的位图图形格式。只不过 PNG 图片是无损压缩，并且支持 alpha 通道，而 JPEG 图片则是有损压缩，可以指定 0-100% 的压缩比。值得一提的是，在苹果的 SDK 中专门提供了两个函数用来生成 PNG 和 JPEG 图片：
```Objective-c
// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format
UIKIT_EXTERN NSData * __nullable UIImagePNGRepresentation(UIImage * __nonnull image);

// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)
UIKIT_EXTERN NSData * __nullable UIImageJPEGRepresentation(UIImage * __nonnull image, CGFloat compressionQuality);
```
==因此，在将磁盘中的图片渲染到屏幕之前，必须先要得到图片的原始像素数据，才能执行后续的绘制操作，这就是为什么需要对图片解压缩的原因。==

#### 将 UIImage 保存到磁盘，用什么方式最好？
- 直接用 NSKeyedArchiver 把 UIImage 序列化保存；
- 用 UIImagePNGRepresentation() 先把图片转为 PNG 保存；
- 用 UIImageJPEGRepresentation() 把图片压缩成 JPEG 保存。
实际上，NSKeyedArchiver 是调用了 UIImagePNGRepresentation 进行序列化的，用它来保存图片是消耗最大的。苹果对 JPEG 有硬编码和硬解码，保存成 JPEG 会大大缩减编码解码时间，也能减小文件体积。所以如果图片不包含透明像素时，UIImageJPEGRepresentation(0.9) 是最佳的图片保存方式，其次是 UIImagePNGRepresentation()。

#### UIImage 缓存是怎么回事？
通过 imageNamed: 创建 UIImage 时，系统实际上只是在 Bundle 内查找到文件名，然后把这个文件名放到 UIImage 里返回，并没有进行实际的文件读取和解码。当 UIImage 第一次显示到屏幕上时，其内部的解码方法才会被调用，同时解码结果会保存到一个全局缓存。

在图片解码后，App 第一次退到后台和收到内存警告时，该图片的缓存才会被清空，其他情况下缓存会一直存在(待验证)。

#### 用 imageWithData: 能不能避免缓存呢？
不能。通过数据创建 UIImage 时，UIImage 底层是调用 ImageIO 的 CGImageSourceCreateWithData() 方法。该方法有个参数叫 ShouldCache，在 64 位的设备上，这个参数是默认开启的。这个图片也是同样在第一次显示到屏幕时才会被解码，随后解码数据被缓存到 CGImage 内部。与 imageNamed: 创建的图片不同，如果这个图片被释放掉，其内部的解码数据也会被立刻释放。

#### 怎么能避免缓存?
1. 手动调用 CGImageSourceCreateWithData() 来创建图片，并把 ShouldCache 和 ShouldCacheImmediately 关掉。这么做会导致每次图片显示到屏幕时，解码方法都会被调用，造成很大的 CPU 占用。
2. 把图片用 CGContextDrawImage() 绘制到画布上，然后把画布的数据取出来当作图片。这也是常见的网络图片库的做法。

#### UIImage加载方法对比
Apple官方的文档为生成一个UIImage对象提供了两种方法：

1. imageNamed,其参数为图片的名字；优点：加载时会缓存图片，用于图片的频繁使用；缺点：占用内存，直到应用结束
2. imageWithContentsOfFile，其参数也是图片文件的路径。优点：仅加载图片，不会缓存，用于价值次数较少的情况，降低内存消耗

#### 小结
- 解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。
- 当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。

### 如何计算图片加载内存中所占的大小
图片内存大小的计算公式是 ：图片高度 * 图片宽度 * 一个像素占用的字节数

## 数据安全及加密
### 对称加密和非对称加密的区别？
1. 对称加密又称公开密钥加密，加密和解密都会用到同一个密钥，如果密钥被攻击者获得，此时加密就失去了意义。常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。
2. 非对称加密又称共享密钥加密，使用一对非对称的密钥，一把叫做私有密钥，另一把叫做公有密钥；公钥加密只能用私钥来解密，私钥加密只能用公钥来解密。常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）。

### 简述 SSL 加密的过程用了哪些加密方法，为何这么做？
SSL 加密，在过程中实际使用了 对称加密 和 非对称加密 的结合。主要的考虑是先使用 非对称加密 进行连接，这样做是为了避免中间人攻击秘钥被劫持，但是 非对称加密 的效率比较低。所以一旦建立了安全的连接之后，就可以使用轻量的 对称加密。

### iOS的签名机制
![](media/16321370027980/16378507872657.jpg)
根据上图，我们重新列一下整个流程：
1.在开发者电脑生成一对公私钥，这里称公钥L，私钥L
2.苹果自己有固定的一对公私钥，这里称为公钥A，私钥A，公钥A内置在iOS系统中，私钥A由苹果后台管理
3.把公钥L传到苹果后台，苹果后台用私钥A对公钥L进行签名，得到一份数据包含公钥L及其签名，这里称这份数据为证书
4.在苹果后台申请AppID，配置好设备ID列表和App可使用的权限，再加上第三步得到的证书组成的数据用私钥A签名，把数据和签名一起组成Provisioning Profile文件，下载到开发者的本机
5.在开发时，编译完一个App后，用本地的私钥L对这个App签名，同时把第4步得到Provisioning Profile文件打包进App里，文件名为embedded.mobileprovision，把App安装到手机上
6.在安装时，iOS系统取得证书，通过系统内置的公钥A去验证embedded.mobileprovision里的签名是否正确
7.确保embedded.mobileprovision里的数据都是经过苹果授权之后，就可以取出里面的数据，做各种验证，包括用公钥L验证App签名，验证设备ID是否在ID列表上，AppID是否对应得上，权限开关是否跟App里的entitlements对应等。


## Runtime
==iOS进阶整理文档==里有详细的知识点总结，这里是补充。
### Category 的实现原理
- 分类底层是一个结构体：struct category_t;结构体里包含分类的名字，所属的类，实例方法列表，类方法列表，协议，实例属性以及类属性。
- Category 在刚刚编译完的时候，和原来的类是分开的，只有在程序运行起来后，通过 Runtime ，Category 和原来的类才会合并到一起。
- Category在运行时，新添加的方法，都被插入到原有类的方法列表的最前面，所以不同的Category，添加了同一个方法，执行的实际上是最后一个。
- Category是不可以添加属性的，利用@property声明属性相当于生成setter方法、getter方法和带下划线的成员变量，但是成员变量列表只保存在类的class_ro_t结构体里，这个结构体是在编译的时候生成的，是不可以改变的，而分类是运行时才去加载的，因此，在分类里添加属性就相当于破坏了类的内存布局，所以是不可以添加的。
- 但是我们可以在分类里通过关联对象的操作来实现添加属性，利用关联对象将变量的setter方法和getter方法关联起来。

### isa指针的理解，对象的isa指针指向哪里？isa指针有哪两种类型？
实例对象的isa指针指向它的类对象
类对象的isa指针指向它的元类
元类的isa指针指向基类的元类
基类的元类的isa指针指向自身
![](media/16321370027980/16379276929228.jpg)

isa 有两种类型
- 纯指针，指向内存地址
- NON_POINTER_ISA，除了内存地址，还存有一些其他信息

### Objective-C 如何实现多重继承？
Object-c的类没有多继承,只支持单继承,如果要实现多继承的话，可使用如下几种方式间接实现
- 通过协议实现
    - C类实现A和B类的协议方法
- 消息转发实现


### runtime 如何实现 weak 属性
weak 此特质表明该属性定义了一种「非拥有关系」(nonowning relationship)。为这种属性设置新值时，设置方法既不持有新值（新指向的对象），也不释放旧值（原来指向的对象）。

程序会维护一个全局SideTables，在真机上，SideTables里维护8个SideTable，SideTable上有weak表；在SideTables通过对象的内存地址定位到所在的SideTable，在SideTable的weak表上通过对象的内存地址定位到对象的weak_entry_t上，里面保存着指向该对象的弱引用。

runtime 如何实现 weak 属性具体流程大致分为 3 步：
- 初始化时：runtime 会调用 objc_initWeak 函数，初始化一个新的 weak 指针指向对象的地址。
- 添加引用时：objc_initWeak 函数会调用 objc_storeWeak() 函数，然后会调用weak_register_no_lock函数，在里面根据对象的内存地址拿到对象的弱引用入口，如果入口为nil，那就会该对象创建weak_entry_t，将添加弱引用，再把弱引用入口添加到weak table上；如果不为nil，那么在弱引用入口里添加弱引用。在这个过程中，为了防止多线程中竞争冲突，会有一些锁的操作。
- 释放时：调用 clearDeallocating 函数，clearDeallocating 函数首先根据对象地址获取所有 weak 指针地址的数组，然后遍历这个数组把其中的数据设为 nil，最后把这个 entry 从 weak 表中删除，最后清理对象的记录。

### 讲一下 OC 的消息机制
OC中的方法调用其实都是转成了objc_msgSend函数的调用，给receiver（方法调用者）发送了一条消息（selector方法名）

#### objc_msgSend工作原理
- 实例对象调用方法时
- 首先通过对象的isa指针找到类对象objc_class
- 到类对象的方法缓存里查看是否有对应的方法
- 在类对象的结构体里，通过bits.data()方法找到class_rw_t结构体，在该结构体里查找方法列表method_array_t，method_array_t里保存的是method_list_t，method_list_t里是method_t
- method_t里保存了每个方法的信息，包括
    1.选择子
    2.方法类型
    3.方法实现imp
- 如果都找不到，那么就会沿着继承树往上搜索，如果都找不到，那么就会进行消息转发。

#### 消息转发
要注意：三次消息转发是会走继承树的，比如resolveInstanceMethod方法在子类没有实现，super类实现了也是会调用到的。

第一次机会：所属类动态方法解析
可以重写该方法，调用class_addMethod函数动态添加方法
```Objective-c
+(BOOL)resolveInstanceMethod:(SEL)name

class_addMethod([self class], name, (IMP)dynamicAdditionMethodIMP, "v@:");
```

第二次机会：备援接收者
如果对象所属的类不能动态添加方法后，runtime会询问当前的接收者是否有其他对象可以处理这个未知的selector，相关的方法声明如下：
```Objective-c
- (id)forwardingTargetForSelector:(SEL)aSelector;
```

第三次机会：消息重定向
先查询methodSignatureForSelector：，看是否得到有效的方法签名，如果有再到-forwardInvocation:进行消息转发。
```Objective-c
- (void)forwardInvocation: (NSInvocation*)invocation;
```
调用这个方法如果不能处理就会调用父类的相关方法，一直到NSObject的这个方法，如果NSObject都无法处理就会调用doesNotRecognizeSelector：方法抛出异常

##### 关于消息转发的一些注意点：
1. 备用接收者`forwardingTargetForSelector`和消息重定向`forwardInvocation`本质上都是将消息转发给另一个对象的作用，区别就在于：消息重定向可以将消息转发给多个对象，而备用接收者只能转发给一个对象。
2. 当实现了备用接收者方法或者消息重定向方法之后，将消息转发给新对象，其实相当于再次调用objc_msgSend方法进行消息转发
3. 在重写消息重定向方法前，一定要重写方法签名方法`methodSignatureForSelector`，在文档里有关于这个方法的描述是这样的：如果要进行消息重定向，那么必须要通过这个方法来返回一个方法签名，用于创建NSInvocation对象，在objc4源码里，如果不重写这个方法，默认是崩溃的。
4. 在重写消息重定向方法时，如果只是单纯地不想让程序崩溃，那么可以在方法实现时简单地填写几条无关的语句，比如输出语句，那么程序检测到该方法实现了，是不会继续调用父类的方法，进而不会让程序崩溃。
5. 消息转发如果走的是消息重定向，那么该方法`resolveInstanceMethod`是会被调用两次的；第一次是刚开始消息转发的时候，即查看能否动态添加方法的时候；第二次是在执行完方法签名之后会再调用一次。具体是为什么？网上有的博客说是再给一次机会查看runtime是否有动态添加方法，这次调用是不会走备用接收者方法的，如果runtime没添加，直接到消息重定向方法的。==这部分源码看的有点吃力，以后可以回看一下==
```C
Discussion
This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.
```

#### runtime的具体应用
![](media/16321370027980/16379319825178.png)
[具体链接🔗](https://blog.csdn.net/box_kun/article/details/109055485)

### runtime如何通过selector找到对应的IMP地址？
类对象objc_class通过成员变量bits.data()方法可以得到class_rw_t结构体，里面存储了方法列表，方法列表里的每个方法结构体存储着方法的名称、实现以及方法类型，而selector本质就是方法名称，通过方法名称在方法列表里查找。
- 实例方法就在类对象的方法列表里进行查找
- 类方法就在元类的方法列表里进行查找

### load和initialize的区别
- 调用时机不一样：load方法是在main函数之前被调用的，initialize方法是在main函数之后而且是在被第一次发送消息的时候被调用
- load方法的调用顺序是：superClass -> class -> category；initialize方法的调用顺序是：superClass -> class。都不需要显示调用父类的方法，系统会自动调用，load方法是函数指针调用，initialize是发送消息。子类如果没有实现load函数，子类是不会调用父类的load函数的，但是子类没有实现initialize函数，则会调用父类的initialize函数。
- 当有多个Category都实现了initialize方法,会覆盖类中的方法,只会调用编译顺序中最后一个分类的initialize方法(initialize方法是走消息发送的，那么分类中的方法在runtime初始化后会合并到类方法列表中，因此会覆盖类本身的initialize方法)
- load和initialize内部实现都加了线程锁，是线程安全的，因此，这两个函数应该做一些简单的工作，不适合复杂的工作。
- load函数通常用来进行Method Swizzle，initialize函数则通常初始化一些全局变量，静态变量。

### 怎么理解Objective-C是动态运行时语言。
我们都知道OC是一门动态语言，其动态特性主要表现为三方面：
- 动态类型识别
    - 即运行时再决定对象的类型。比如id类型，id指针可以指向任何对象，只有在运行时才能确定这个对象的类型，而如果静态类型，那么在编译器编译的时候就会被识别出来，但如果识别出类型不对应，编译器会发出警告，那么就会在运行时才能确定对象的类型。比如`NSData *test = [[NSString alloc]init];`，编译时会确定test对象为NSData类型，但是运行后会将test对象类型改为NSString类型
- 动态绑定
    - 理解为运行时决定调用的方法；基于动态类型，在运行时确定对象的类型后，才能确定对象对应的属性以及响应方法，也就是说在运行时才判断需要调用什么方法，而不是在编译时就确定了。而且在OC消息转发机制中，我们可以在运行给类动态添加实例方法或者类方法以及对消息进行重定向，这些都是运行时才确定的。
- 动态加载
    - 在运行时可以动态地添加属性、方法、以及协议。

## RunLoop
### RunLoop概念
RunLoop理解为运行循环。其本质就是一个`do-while`，这里的do-while和普通的do-while循环不一样，一般的 while 循环会导致 CPU 进入忙等待状态，而 Runloop 则是一种“闲”等待，当没有事件时，Runloop 会进入休眠状态，有事件发生时， Runloop 会去找对应的 Handler 处理事件。Runloop 可以让线程在需要做事的时候忙起来，不需要的话就让线程休眠。
![](media/16321370027980/16380928071205.jpg)
图中展现了 Runloop 在线程中的作用：从 input source 和 timer source 接受事件，然后在线程中处理事件。

### RunLoop 作用
1. 保持程序持续运行。程序启动就会自动开启一个runloop在主线程
2. 处理App中的各种事件
3. 节省CPU资源，提高程序性能 有事情则做事，没事情则休眠

### RunLoop 和线程之间的关系
- Runloop 和线程是绑定在一起的。每个线程（包括主线程）都有一个对应的 Runloop 对象。我们并不能自己创建 Runloop 对象，但是可以获取到系统提供的 Runloop 对象。
- 主线程的 Runloop 会在应用启动的时候完成启动，其他线程的 Runloop 默认并不会启动，需要我们手动启动。

底层RunLoop的存储使用的是字典结构，线程是key，对应的runloop是value。
1. 主线程是默认开启RunLoop的
2. 子线程是默认不开启RunLoop的
3. 子线程开启RunLoop需要我们手动开启，手动开启时会先在全局的存储字典里根据传入的线程key，查看value是否存在，不存在的话就基于线程为key创建一个新的runloop并存储进字典里。

### RunLoop Mode
RunLoop Mode可以理解为RunLoop的运行模式，在苹果文档里定义了有五种运行模式。
```C
- kCFRunLoopDefaultMode, App的默认运行模式，通常主线程是在这个运行模式下运行
- UITrackingRunLoopMode, 跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）
- kCFRunLoopCommonModes, 伪模式，不是一种真正的运行模式
- UIInitializationRunLoopMode：在刚启动App时第进入的第一个Mode，启动完成后就不再使用
- GSEventReceiveRunLoopMode：接受系统内部事件，通常用不到
```

在源码里搜索__CFRunLoopMode可以看到里面的内部结构，提取出关键的成员变量。
1. _name：Mode的名字
2. _sources0：
    1. App内部事件，由App自己管理的，像UIEvent、CFSocket、以及performSelector不带afterDelay参数的方法都是source0
    2. source0不能主动触发，需要调用CFRunLoopWakeUp(runloop) 来唤醒 RunLoop
3. _sources1：
    1. 由RunLoop和内核管理，Mach port驱动，如CFMachPort、CFMessagePort。
    2. source1包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息
    3. 能主动唤醒 RunLoop 的线程
4. _observers：添加的观察者
5. _timers：定时器，包括NSTimer、CADisplayLink以及performSelector带afterDelay参数的方法。

```C
struct __CFRunLoopMode {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;	/* must have the run loop locked before locking this */
    CFStringRef _name;
    Boolean _stopped;
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
    __CFPortSet _portSet;
}
```

### RunLoop的本质
RunLoop底层其实就是一个结构体，通过源码搜索__CFRunLoop。
提取出关键的成员变量_pthread、_currentMode以及_modes，可以发现
1. RunLoop和线程是绑定的，每个线程会有对应的RunLop，只是主线程是默认开启的，子线程不是默认开启的，需要手动开启，然后底层就会根据传入的线程创建新的RunLoop
2. _currentMode：当前运行的Mode
3. _modes：多个mode的集合


```C
struct __CFRunLoop {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;			/* locked for accessing mode list */
    __CFPort _wakeUpPort;			// used for CFRunLoopWakeUp 
    Boolean _unused;
    volatile _per_run_data *_perRunData;              // reset for runs of the run loop
    pthread_t _pthread;
    uint32_t _winthread;
    CFMutableSetRef _commonModes;
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
    struct _block_item *_blocks_head;
    struct _block_item *_blocks_tail;
    CFAbsoluteTime _runTime;
    CFAbsoluteTime _sleepTime;
    CFTypeRef _counterpart;
};
```


通过上面的整理可以发现
1. RunLoop管理着多个mode
2. 每次RunLoop运行的的时候都必须指定一个mode作为_currentMode，如果需要执行其他mode的事务，那么就要先退出当前mode，然后切换另一个mode
3. mode里面管理着source0、source1、timers、observers以及port端口的事务。

引用来自掘金博主的图片🌟
![](media/16321370027980/16381026243792.jpg)

### RunLoop的核心方法
通过查找源码，我们可以发现三个关键的方法
```C
//通知观察者即将进入RunLoop
	if (currentMode->_observerMask & kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
	//进入RunLoop的关键方法
	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
	//通知观察者即将退出RunLoop
	if (currentMode->_observerMask & kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
```

#### __CFRunLoopRun
以下代码引用掘金博主的源码解析
通过下面的源代码解析，可以将RunLoop的处理逻辑理为
1. 通知观察者，即将进入runloop
2. 通知观察者，即将处理Timers
3. 通知观察者，即将处理Sources
4. 执行加入到runloop的blocks
5. 处理Source0，处理之后可能会再次处理blocks
6. 如果存在Source1，直接跳转到第9步
7. 通知观察者，即将进入休眠
8. 通知观察者，结束休眠
9. 执行唤醒RunLoop的事件
    1. 处理timer事件
    2. 执行gcd通过异步函数提交任务到主线程的Block
    3. 处理Source1事件
    4. 被手动唤醒，不需要执行事件，单纯起到唤醒RunLoop的功能
10. 执行加入到runloop的blocks
11. 根据以下情况来确定是否要退出当前RunLoop
    1. 进入run方法时参数表明处理完事件就返回。
    2. 超出run方法参数中的超时时间
    3. 被外部调用者强制停止了
    4. 调用_CFRunLoopStopMode将mode停止了
    5. 检测还有没有待处理的sources/timer/observer
    6. 以上🈚五种情况均无的话 那么就跳转到第2步，继续循环
12. 通知观察者，退出RunLoop


```C

do {
// 消息缓冲区，用户缓存内核发的消息
uint8_t msg_buffer[3 * 1024]; 
//取所有需要监听的port
__CFPortSet waitSet = rlm->_portSet;
//设置RunLoop为可以被唤醒状态
__CFRunLoopUnsetIgnoreWakeUps(rl);

//1.通知 Observers: RunLoop 即将处理 Timer 回调。
if (rlm->_observerMask & kCFRunLoopBeforeTimers) 
__CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);

//2。通知 Observers: RunLoop 即将触发 Source(非port) 回调
 if (rlm->_observerMask & kCFRunLoopBeforeSources) 
 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);

// 执行被加入的block
//外部通过调用CFRunLoopPerformBlock函数向当前runloop增加block。新增加的block保存咋runloop.blocks_head链表里。
//__CFRunLoopDoBlocks会遍历链表取出每一个block，如果block被指定执行的mode和当前的mode一致，则调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__执行
 __CFRunLoopDoBlocks(rl, rlm);

//RunLoop 触发 Source0 (非port) 回调
// __CFRunLoopDoSources0函数内部会调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__函数
//__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__函数会调用source0的perform回调函数，即rls->context.version0.perform
Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);

//处理了source0后再次处理blocks
if (sourceHandledThisLoop) {
     __CFRunLoopDoBlocks(rl, rlm);
 }
//
Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context->termTSR);
didDispatchPortLastTime = false;

//如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。
msg = (mach_msg_header_t *)msg_buffer;
if (__CFRunLoopServiceMachPort(dispatchPort, &msg, sizeof(msg_buffer), &livePort, 0, &voucherState, NULL)) {
     goto handle_msg;
}

//通知oberver即将进入休眠状态
if(!poll && (rlm->_observerMask & kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
__CFRunLoopSetSleeping(rl);

//接收waitSet端口的消息
//等待接受 mach_port 的消息。线程将进入休眠
msg = (mach_msg_header_t *)msg_buffer;
__CFRunLoopServiceMachPort(waitSet, &msg, sizeof(msg_buffer), &livePort, poll ? 0 : TIMEOUT_INFINITY, &voucherState, &voucherCopy);

 // 计算线程沉睡的时长
 rl->_sleepTime += (poll ? 0.0 : (CFAbsoluteTimeGetCurrent() - sleepStart));
 
 __CFPortSetRemove(dispatchPort, waitSet);
 __CFRunLoopSetIgnoreWakeUps(rl);
  // runloop置为唤醒状态
 __CFRunLoopUnsetSleeping(rl);
  // 8. 通知 Observers: RunLoop对应的线程刚被唤醒。
 if (!poll && (rlm->_observerMask & kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);

//收到处理的消息进行处理
handle_msg:;
// 忽略端口唤醒runloop，避免在处理source1时通过其他线程或进程唤醒runloop(保证线程安全)
__CFRunLoopSetIgnoreWakeUps(rl);

if(MACH_PORT_NULL == livePort){
// livePort为null则什么也不做

}else if(livePort == rl->_wakeUpPort){
// livePort为wakeUpPort则只需要简单的唤醒runloop（rl->_wakeUpPort是专门用来唤醒runloop的）
 CFRUNLOOP_WAKEUP_FOR_WAKEUP();

}else if (rlm->_timerPort != MACH_PORT_NULL && livePort == rlm->_timerPort){
    //如果是一个timerPort
// 如果一个 Timer 到时间了，触发这个Timer的回调
// __CFRunLoopDoTimers返回值代表是否处理了这个timer
 if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) {
     __CFArmNextTimerInMode(rlm, rl);
 }
}else if(livePort == dispatchPort){
   //如果是GCD port
   //处理GCD通过port提交到主线程的事件
__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
}else{
    // 处理source1事件（触发source1的回调）
    //// runloop 触发source1的回调，__CFRunLoopDoSource1内部会调用__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__
   __CFRunLoopDoSource1(rl, rlm, rls, msg, msg->msgh_size, &reply)
}


/// 执行加入到Loop的block
 __CFRunLoopDoBlocks(rl, rlm);
        
if (sourceHandledThisLoop && stopAfterHandle) {
     /// 进入loop时参数说处理完事件就返回。
     retVal = kCFRunLoopRunHandledSource; // 4
} else if (timeout_context->termTSR < mach_absolute_time()) {
            /// 超出传入参数标记的超时时间了
            retVal = kCFRunLoopRunTimedOut; // 3
        } else if (__CFRunLoopIsStopped(rl)) {
            /// 被外部调用者强制停止了
            __CFRunLoopUnsetStopped(rl); // 2
            retVal = kCFRunLoopRunStopped;
        } else if (rlm->_stopped) {
            // 调用了_CFRunLoopStopMode将mode停止了
            rlm->_stopped = false;
            retVal = kCFRunLoopRunStopped; // 2
        } else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
            // source0/source1/timers/blocks一个都没有了
            retVal = kCFRunLoopRunFinished; // 1
        }
}while(0 == retVal)
```

##### __CFRunLoopDoBlocks
解析关于runloop调用的blocks，而Source0、Source1、timers以及Observers 在前面已经解析过了。
这个方法主要处理Blocks回调。
- runloop对象有一个_block_item结构的链表，里面存储着当前runloop待处理的blocks
- 执行`__CFRunLoopDoBlocks`方法就是遍历runloop的链表，取出blocks，然后执行` __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);`方法
- KVO回调方法，以及在主线程调用的block；这两种情况回调由` __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);`方法调用执行


##### __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);
- 在调用GCD的异步函数`dispatch_async`，往主线程里添加任务时会触发该方法
- 由于自线程默认是没有开启Runloop的，子线程下执行GCD的任务是不会被添加到RunLoop上的，子线程blocks的执行是由`lidbdispatch`驱动完成的。

### RunLoop的应用
#### AutoreleasePool
App启动后，苹果在主线RunLoop里注册了两个观察者，分别观察RunLoop的即将进入loop事件、即将进入休眠事件、即将退出事件。
- 即将进入loop事件触发时会调用`_objc_autoreleasePoolPush()`方法创建自动释放池以及插入哨兵对象
- 即将进入休眠事件触发时会分别调用`_objc_autoreleasePoolPop()` 和 `_objc_autoreleasePoolPush() `方法，释放旧的自动释放池并release里面的对象以及创建新的自动释放池
- 即将退出事件触发时会调用`_objc_autoreleasePoolPop()` 方法，释放自动释放池。

#### NSTimer
`NSTimer`就是上文提到的`timer`
- 底层`Runloop`会在每个时间点都注册一个事件，到了事件点进行回调，但是并不是每次都是很准确地在指定时间点进行回调的，`timer`中有一个属性`Tolerance`标识可以容忍多大的误差。
- 如果`RunLoop`有很多要处理的事，错过了`timer`指定的时间点，那么是会错过此次回调的。
- 默认在主线创建的`timer`都会自动加入到`RunLoop`中，而如果是在子线程中创建的`timer`，在没有开启`RunLoop`的情况下，其实是无效的。



#### CADisplayLink
- `CADisplayLink`是一个执行频率（fps）和屏幕刷新相同的定时器，需要加入到RunLoop才能执行。但是我们也可以通过调用API来实现更改执行频率。
- 它与`NSTimer`都是定时器，区别在于`CADisplayLink`的精度更高，而`NSTimer`的使用范围更加地广泛。

#### 事件响应
- 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 `__IOHIDEventSystemClientQueueCallback()`。
- 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 `_UIApplicationHandleEventQueue() `进行应用内部的分发。
- `_UIApplicationHandleEventQueue()` 会把 `IOHIDEvent `处理并包装成 `UIEvent` 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。

#### 手势识别
- 当上面的 `_UIApplicationHandleEventQueue()` 识别了一个手势时，其首先会调用` Cancel` 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。
- 苹果注册了一个 `Observer` 监测 `BeforeWaiting` (Loop即将进入休眠) 事件，这个Observer的回调函数是 `_UIGestureRecognizerUpdateObserver()`，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。
- 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

#### UI更新
当修改了View的frame等导致View的图层发生了变化或者手动调用了`setNeedsDisplay/setNeedsLayout`方法之后就会将这个View标记放进一个全局容器里面，当`RunLoop`的即将进入休眠或者退出事件回调时，就会遍历这个全局容器将UI进行绘制更新。


### 其他一些面试常问点
#### GCD 在Runloop中的使用
1. 在主线程调用GCD的异步函数`dispatch_async`，将任务添加到主线程中，会触发RunLoop的`__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__`方法
2. 在子线程中执行的任务是不会触发到RunLoop的相关事件的，因为子线程默认是没有开启RunLoop的，子线程block的执行是靠`lidbdispatch`来驱动实现的。

#### AFNetworking 中如何运用 Runloop？
`AFNetworking`是一个网络请求的第三方框架，它是基于`NSURLConnection`创建的，AFN的设计思想是希望在后台开启一条新线程，可以持续监听delegate的回调。
主要的代码实现
- 由于子线程默认是不开启RunLoop的，但是我们可以通过获取当前子线程即`currentThread`方法来让系统给当前线程创建一个新的RunLoop，新创建的RunLoop如果没有持有Source0、Source1或者timers，那么新创建的RunLoop就有可能被释放掉，因此在RunLoop调用run方法前给RunLoop添加一个Port，就是让RunLoop不退出，能够一直运行。
- 这里的自动释放池就是为了延长runloop的声明周期，避免runloop被创建出来由于没有持有runloop 源而立马被释放。

```Objective-c
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];
        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });
    return _networkRequestThread;
}
```
当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。
```Objective-c
- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;
        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}
```

#### PerformSelector 的实现原理
- 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。
- 当调用 performSelector:onThread: 时，触发的是Source0事件，同样的，如果对应线程没有 RunLoop 该方法也会失效。
    - 网上有的博客说调用performSelector:onThread: 时，同样也是会创建一个Timer并添加到当前线程的RunLoop，但是我打印堆栈信息调试出的结果是Source0触发的，并不是Timer事件。

#### 事件响应的过程
- 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。

- 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的 App 进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。

- _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。

#### 手势识别的过程
- 当 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。

- 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个 Observer 的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer 的回调。

- 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。

#### CADispalyTimer和Timer哪个更精确
CADisplayLink 更精确
两者都会被添加进RunLoop

- iOS设备的屏幕刷新频率是固定的，CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。

- NSTimer的精确度就显得低了点，比如NSTimer的触发时间到的时候，runloop如果在阻塞状态，触发时间就会推迟到下一个runloop周期。并且 NSTimer新增了tolerance属性，让用户可以设置可以容忍的触发的时间的延迟范围。

- CADisplayLink使用场合相对专一，适合做UI的不停重绘，比如自定义动画引擎或者视频播放的渲染。NSTimer的使用范围要广泛的多，各种需要单次或者循环定时处理的任务都可以使用。在UI相关的动画或者显示内容使用 CADisplayLink比起用NSTimer的好处就是我们不需要在格外关心屏幕的刷新频率了，因为它本身就是跟屏幕刷新同步的。

[学习链接🔗](https://juejin.cn/post/6863452695144071175#heading-2)

#### 关于GCD Timer
GCD定时器是三种定时器（NSTimer、CADisplayLink、GCD TImer）中，时间最为准确的。因为GCD定时器不依赖与NSRunLoop, GCD定时器实际上是使用了dispatch源(dispatch source)，dispatch源监听系统内核对象并处理，通过系统级调用，更加精准。（内核对象 - 我觉得可以理解为操作系统内核中的计时器）

- NSTimer和CADisplayLink依赖于RunLoop，如果RunLoop的任务过于繁重，可能会导致NSTimer不准时，相比之下GCD的定时器会更加准时，因为GCD不是依赖RunLoop，而是由内核决定


- CADisplayLink和NSTimer会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用

## 项目架构
### MVC、MVP、MVVM模式
#### MVC模式
MVC模式，即Model-View-Controller。它是苹果公司官方推荐的 App 开发架构，也是一般开发者最先遇到、最经典的架构。  图下所示的是 MVC架构的示意图。
![未命名文件 -2-](media/16321370027980/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-2-.jpg)
上图持有关系为`Controller`是同时持有`View`跟`Model`的；
1. 当`View`发生交互事件时，会通过`action`通知到`Controller`，`Controller`收到之后会去更新`Model`层的数据
2. 当`Model`层的数据发生变化时，也会通知`Controller`层，之后会去更新`View`层
3. 可以看出，`View`层跟`Model`层之间的通信都是依赖`Controller`层的，`Controller`层相当于中介者，同时协调着`View`层跟`Model`层。


那么，在MVC模式下，App的组成可以分为三部分
1. Model层：负责数据的持久化存储以及读取操作
2. View层：负责视图数据的展示和交互
3. Controller层：充当中介者，负责连接model层和view层。它将数据从model层传递到view层，同时将view层的交互传递到model层从而改变模型存储的数据。

==优点==
1. 代码总量少。基本上，MVC大量的逻辑和视图代码都集中在ViewController层，Model层只是实现简单的数据存储，View层主要负责视图数据的展示和交互。
2. 简单易懂。MVC的设计模式可以让开发者很容易熟悉以及上手。

==缺点==
MVC的缺点也很明显，大量的代码都集中在了Controller层。
1. 代码过于集中。ViewController层集合了视图的交互、视图的更新、布局、Model数据的获取以及更新、网络请求等业务逻辑等大量的代码。
2. 难以进行测试。大量的代码都堆积在了ViewController层，高度耦合难以测试。
3. Model层过于简单。相比 ViewController 的庞大代码，Model 层只是定义几个属性在 Objective-C 的.m 实现文件中，更是几乎看不到代码。
4. 网络请求逻辑无从安放。网络层放在 Model 中，网络请求一般是异步调用的，那如果网络请求的周期比Model对象的生命周期还要长，那么就会使Model层的逻辑变得很复杂，若是将网络层放在ViewController中，则耦合进一步加剧，以上缺点更会被放大。

#### MVP
MVP模式的提出旨在解决MVC模式下Controller层过于臃肿的问题，那么在MVP模式下，会将Controller层的处理视图交互、发起网络请求更新Model数据以及更新视图View等一部分的业务逻辑抽离出来，减轻了Controller层的负担。

MVP的示意图如下：
 ![MVP模式](media/16321370027980/MVP%E6%A8%A1%E5%BC%8F.jpg)
从图中可以看出：
MVP模式是在MVC模式上衍生出了一个Presenter层，以及更新了不同层之间的持有关系。
- View层以及Controller层持有Presenter层
- Presenter层持有Model层

每层的分工
1. View层：这里的View层是包含View以及Controller的。主要负责视图的布局以及一部分的视图交互。
2. Model层：依然是负责数据的持久化存储以及读取。
3. Presenter层：负责接收来自View层的交互，并更新数据到Model层，当Model层数据变更时，负责通知View层更新视图。

根据不同层之间的持有关系，我们可以推断出MVP模式的工作逻辑：
1. View层和Controller层都持有presenter层，而视图交互逻辑主要在presenter层，那么内部实现应该是View层将视图交互通知到presenter层，但是本身View层创建出的视图是被addSubView进Controller层的根视图的，所以Controller层又会持有View层，那么另一种实现可以是：Controller层作为View层的代理，View层将处理视图交互的操作定义在协议里，将交互事件传递给Controller层，而Controller层本身持有presenter层，那么就调用presenter层实现的对于视图交互的方法。
2. 要注意的是，Controller层始终是核心层，它负责对于各个层主要的连接以及管理。

简单理一下用户交互的事件传递流程：
用户点击View视图 -> View视图触发交互事件 -> 交互事件传递代理Controller层 -> Controller层调用Presenter层实现好的交互操作 -> 发起网络请求更新持有的model数据 -> model层更新完毕之后通过代理或者通知到Presenter层 -> Presenter层再通过代理或通知通知到Controller层或者View层。
[具体的MVP设计实例](https://juejin.cn/post/6844903700113129485)

==优点==
1. 相比于MVC，减轻了Controller层的负担，耦合度大大降低

==缺点==
view的所有交互都要传给Presenter处理，从而一旦功能增加了，View的代码和Presenter的代码都会增加，相比于MVC在ViewController一个文件里面直接解决，MVP的总代码量可能会翻倍，这样App的维护成本和文件都会增大。因此在MVC的基础上又衍生出了一种新的模式MVVM。

#### MVVM
MVVM模式是基于MVC模式的，在MVC的基础上分离出业务处理的逻辑到ViewModel层，即
![未命名文件 -3-](media/16321370027980/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20-3-.jpg)
![-w439](media/16321370027980/16382388775592.jpg)

MVVM设计模式的示意图其实跟MVP的很相似，第二张图是MVP设计模式的示意图。
可以发现
- 在View层跟View Model层之间是双向的，但这不是相互持有的关系，这是一种类似于通知的方法，当View的数据发生变化会自动通知到View Model，当View Model的数据发生变化，也会自动通知到View，所以总的来说，MVVM模式就是在MVP模式上新增了双向绑定。
- 目前主流的双向绑定方案主要有RAC以及KVO
- View/Controller 持有 View Model ，View Model持有Model，那说明View Model的职责在于分担Controller层的视图交互、网络请求、更新Model模型数据等的业务逻辑。
- 尽管在MVVM模式下，没有明确指出Controller层的指责划分，但是我们仍然是将Controller层充当Manager的身份，管理各个层以及将业务逻辑分配到View Model层。

我们再来看一下MVP模式下的业务逻辑
> ![MVP逻辑](media/16321370027980/MVP%E9%80%BB%E8%BE%91.jpg)
而在MVVM模式下，P层通过代理或者通知 通知到V层就不需要定义协议或者通知了，根据KVO或则RAC实现绑定，当一方数据发生变化即会通知到另一方.


==优点==
相比于MVP模式，代码量大大减少。

==缺点==
利用RAC实现双向绑定需要引入第三方响应式框架，而且因为属性观察环环相扣，调用栈变大，Debug起来会比较痛苦。

[学习链接](https://juejin.cn/post/6844903508521680909#heading-25)
[学习链接](https://juejin.cn/post/7024688460724174861#heading-13)
[学习链接](https://juejin.cn/post/6844903865851052039#heading-7)

## 设计模式
### iOS有哪些常见的设计模式
- 单例模式：单例保证了应用程序的生命周期内仅有一个该类的实例对象,而且易于外界访问.在ios sdk中,UIApplication, NSBundle, NSNotificationCenter, NSFileManager, NSUserDefault, NSURLCache等都是单例。
- 委托模式：委托Delegate是协议的一种,通过@protocol方式实现，常见的有tableView，textField等。
- 观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。在iOS中,观察者模式的具体实现有两种: 通知机制(notification)和KVO机制(Key-value Observing)

### 编程中的六大设计原则
- 单一职责原则
通俗地讲就是一个类只做一件事
CALayer：动画和视图的显示。
UIView：只负责事件传递、事件响应。
- 开闭原则
对修改关闭，对扩展开放。当要新增一些新功能，要考虑在原有的基础上进行扩展，而不是修改。
- 接口隔离原则
使用多个专门的协议、而不是一个庞大臃肿的协议，如 UITableviewDelegate + UITableViewDataSource
- 依赖倒置原则
程序要依赖于抽象接口，不要依赖于具体实现，即根据功能模块调用对应接口，并不需要知道里面的具体实现。
- 里氏替换原则
父类可以被子类无缝替换，且原有的功能不受任何影响
- 迪米特法则
一个对象应当对其他对象尽可能少的了解，实现高聚合、低耦合

## 组件
### 组件化有什么好处？
- 业务分层、解耦，使代码变得可维护；

- 有效的拆分、组织日益庞大的工程代码，使工程目录变得可维护；

- 便于各业务功能拆分、抽离，实现真正的功能复用；

- 业务隔离，跨团队开发代码控制和版本风险控制的实现；

- 模块化对代码的封装性、合理性都有一定的要求，提升开发同学的设计能力；

- 在维护好各级组件的情况下，随意组合满足不同客户需求；（只需要将之前的多个业务组件模块在新的主App中进行组装即可快速迭代出下一个全新App）

## 调试技巧
### 常见的lldb调试
- expression
expression即表达式，在控制台利用expression可以实现对一些变量值的修改，比如修改字符串的值，给可变数组添加元素
`expression [array addObject:@"1"]`
`expression name = @"123"`

- p/po 输出指令
两者的区别在于输出的内容不一样。
p指令会输出变量的类型、内存地址、以及内容
po指令输出变量的内容
```Objective-c
(lldb) p name
(NSTaggedPointerString *) $4 = 0xf20c7e9ad1f60059 @"123"
(lldb) po name
123
```

- bt指令
打印从程序运行开始到断点处的调用栈

- 动态改变元素内容
通过打断点，在断点处新增action，利用`expression`指令将a 赋值为3
![-w476](media/16321370027980/16382809550686.jpg)

### 断点调试
先解析一下普通的断点
- name：断点的名字
- Condition：断点发生的条件
- Ignore：断点忽略的次数
- Action：断点后执行的操作 - 利用expression指令
- Options：执行了actions后自动往下
![-w476](media/16321370027980/16382818647209.jpg)

常见的断点
- 条件断点
在Condition设置断点的条件 比如 数值类型 num == 1，变量num为数值1的时候才会触发断点。
![-w476](media/16321370027980/16382822111656.jpg)

- 异常断点
一般用于定位到程序发生crash的地方

- 符号断点
用于只在特定符号处触发断点
比如设置在调用`UIViewController`的`viewDidLoad`方法就会触发断点
要注意的是 符号断点的书写格式`-[UIViewController viewDidLoad]`，要标明是类方法还是实例方法，而且-与[符号要紧贴，否则无效。
![-w476](media/16321370027980/16382823284996.jpg)

- swift错误断点
- runtime异常断点
- OpenGL ES异常断点
- 测试失败断点
- 容器错误断点


### 常见的错误类型
- unrecognized selector crash
找不到对应的方法

- Bad Access crash 
访问了野指针或者出现了死循环

## iOS编译过程
### 基本简介
从源代码生成可执行文件的四个步骤
> 预处理 -> 编译 -> 汇编 -> 链接

而在编译过程可再细分出词法分析、语法分析、生成中间代码、对中间代码进行无关平台的优化、生成汇编代码。
> 预处理 -> 词法分析 -> 语法分析 -> 生成中间代码 -> 中间代码的优化 -> 生成汇编代码 -> 汇编 -> 链接

### 编译器
主流的`C/C++`的编译器有`GCC`，这是`GNU`发布的一款极具影响力的编译器。`iOS`开发使用的`Xcode`目前用的编译器是`clang+LLVM`。`Xcode4`之前，用的是`GCC编译器`，由于`GCC`对`Objective-C`的支持不是很好，于是苹果采用了“自家”发起的`clang+LLVM`作为默认编译器。

目前 `Xode`使用的编译器分为前端`Clang`以及后端`  LLVM`。
- 前端`Clang`负责词法分析、语法分析、生成中间代码
- 后端`Clang`以中间代码作为输入进行无关平台的代码优化，最后输出汇编代码

### 不同阶段的处理
#### 预处理
预处理即处理代码，主要进行将宏插入到指定位置、删除注释、条件优化等的操作。

#### 词法分析
词法分析器的工作流程：逐个读取源文件中的字符，然后根据读到的字符的特点转换状态。简单来说，词法分析器要做的是将源代码分割开，形成一个个单词，作为词法单元输出为语法分析做准备。比如 `a + b`就分成了三个词法单元 `a`,`+`,`b`。

#### 语法分析
词法分析后，编译器已经知道每个单词的意思了，但是这些单词组合起来的语法还不清楚，这时候就需要编译器进行语法分析了。

实现词法分析的一个简单的思路就是模版匹配，即将编程语言的基本语法规则抽象成模板进行匹配，符合相应的模版，则对应相应的意思，同时生成抽象语法树(AST: Abstract Syntax Tree)。

比如有 `int a = 10;` 语句，其实表示了这么一种通用的语法格式: `类型 变量名 = 变量值;。`

根据语法分析得出对应的意思后，会进行抽象语法树的生成，抽象语法树上的每个节点对应词法分析得出的词法单元`  token`，同时还会标记其在源码中的位置。

抽象语法树生成之后，会对其进行`静态分析`，`静态分析`会对代码进行错误检查，如出现方法被调用但是未定义、定义但是未使用的变量、类型检查等，以此提高代码质量。

抽象语法树将字符串格式的源代码转化为树状的数据结构，更容易被计算机理解和处理。但它距离中间代码还有一定的距离。

#### 生成中间代码IR
`AST `会生成` IR`，`IR `是一种更接近机器码的语言，区别在于和平台无关，通过 IR 可以生成多份适合不同平台的机器码。

#### 中间代码优化
编译器后端`LLVM`以中间代码作为输入，对其进行优化，主要进行编译优化，例如针对全局变量优化、循环优化、尾递归优化等，最后输出汇编代码。

#### 汇编
汇编器会将汇编代码转为机器码。此时的代码就是.o文件，即二进制文件。

#### 链接
链接器把目标文件都链接起来形成一个可执行文件。

在一个目标文件中，不可能所有变量和函数都定义在文件内部。比如`strlen `函数就是一个被调用的外部函数，此时就需要把 `main.o` 这个目标文件和包含了 `strlen` 函数实现的目标文件链接起来。我们知道函数调用对应到汇编其实是` jump `指令，后面写上被调用函数的地址，但在生成` main.o `的过程中， `strlen() `函数的地址并不知道，所以只能先用` 0` 来代替，直到最后链接时，才会修改成真实的地址。

链接器就是靠着`重定位表`来知道哪些地方需要被重定位的。每个可能存在重定位的段都会有对应的重定位表。在链接阶段，链接器会根据重定位表中，需要重定位的内容，去别的目标文件中找到地址并进行重定位。
![](media/16321370027980/16383497820856.jpg)


### Mach-O
`Mach-O` 其实是 `Mach Object` 文件格式的缩写，是 `mac` 以及 `iOS` 上可执行文件的格式。
但是除了可执行文件外 , 其实还有一些文件也是使用的 `Mach-O` 的文件格式。
- 目标文件.O
- 库文件
    - .a
    - .Framework
    - .dylib
- 可执行文件
- dyld
- .dsym（符号表）

#### Mach-O 文件结构
可以看出，Mach-O文件由Header、Load commands以及Data三部分组成。
![](media/16321370027980/16383685366610.jpg)

#### Mach-O - Header
以下为Mach-O文件中的Header部分的主要组成，可以看出Mach-O文件的Header部分主要描述CPU的类型以及架构、加载命令的大小、条数。
- magic：帮助定位处理器是32位还是64位，64位处理器的通用寄存器的宽度为64位，可以进行更大范围的数据运算。
- cpu_type_t：CPU的类型
- cpu_subtype_t：CPU的具体架构
- filetype：文件类型
- ncmds：加载命令的条数
- sizeofcmds：加载命令的大小
- flags：标志位
- reserved：保留字段

```C
struct mach_header_64 {
    uint32_t	magic;		/* 魔数,快速定位64位/32位 */
    cpu_type_t	cputype;	/* cpu 类型 比如 ARM */
    cpu_subtype_t	cpusubtype;	/* cpu 具体类型 比如arm64 , armv7 */
    uint32_t	filetype;	/* 文件类型 例如可执行文件 .. */
    uint32_t	ncmds;		/* load commands 加载命令条数 */
    uint32_t	sizeofcmds;	/* load commands 加载命令大小*/
    uint32_t	flags;		/* 标志位标识二进制文件支持的功能 , 主要是和系统加载、链接有关*/
    uint32_t	reserved;	/* reserved , 保留字段 */
};
```

#### Mach-O - Load Commands
在内存中，Load Commands是紧跟着Header之后的。
下图描述了在arm64下Load Commands包含的信息。
主要描述动态链接的相关信息，dyld的加载路径，文件中包含的依赖库的信息、文件的唯一ID、程序的main函数入口地址以及代码签名信息。
![](media/16321370027980/16383695456759.jpg)

#### Mach-O - DATA
Data部分是由一个个Section来组成的，主要有四种类型的sceeion。

| 段         | 含义                               |
|-----------|----------------------------------|
| _PAGEZERO | 空指针陷阱段，映射到虚拟内存空间第一页，捕捉对NULL指针的引用 |
| _TEXT     | 代码段、只读数据段                        |
| _DATA     | 读取和写入数据段                         |
| _LINKEDIT | dyld需要使用的信息，包括重定位、绑定、懒加载信息等      |

[学习链接🔗](https://juejin.cn/post/6844903983841214472#heading-1)

### dyld
#### 简介
`dyld` 全名 `The dynamic link editor` . 它是苹果的动态链接器，是苹果操作系统一个重要组成部分 ，在应用被编译打包成可执行文件格式的 `Mach-O` 文件之后 ，交由 `dyld` 负责链接 , 加载程序 。

#### 共享缓存
解读 dyld 有一个必不可少的东西 - 共享缓存 。
由于 iOS 系统中 UIKit / Foundation 等库每个应用都会通过 dyld 加载到内存中 , 因此 , 为了节约空间 , 苹果将这些系统库放在了一个地方 : 动态库共享缓存区 (dyld shared cache) .   ( Mac OS 一样有 )  。

所有默认的动态链接库被合并成一个大的缓存文件，放到/System/Library/Caches/com.apple.dyld/目录下，按不同的架构保存分别保存着。

比如我们调用`NSLog`函数，寻找真实内存地址的流程如下:
- 在工程编译时 , 所产生的 Mach-O 可执行文件中会预留出一段空间 , 这个空间其实就是符号表 , 存放在 _DATA 数据段中 ( 因为 _DATA 段在运行时是可读可写的 )
- 编译时 : 工程中所有引用了共享缓存区中的系统库方法 , 其指向的地址设置成符号地址 , ( 例如工程中有一个 NSLog , 那么编译时就会在 Mach-O 中创建一个 NSLog 的符号 , 工程中的 NSLog 就指向这个符号 )
- 运行时 : 当 dyld将应用进程加载到内存中时 , 根据 load commands 中列出的需要加载哪些库文件 , 去做绑定的操作  ( 以 NSLog 为例 , dyld 就会去找到 Foundation 中 NSLog 的真实地址写到 _DATA 段的符号表中 NSLog 的符号上面 )

#### dyld 加载流程
1. 配置环境变量，某些环境变量会影响到后续库的加载
2. 加载共享缓存库
3. 实例化主程序
4. 加载动态库
5. 链接主程序
6. 进行OC的初始化，包括加载C++静态函数，初始化Runtime，加载load函数等
7. 最后dyld从Load commands返回main函数的入口地址

因此，在打印堆栈信息时，可以发现，程序入口调用的第一个函数是[dyld start]，而不是main函数。

[学习链接](https://juejin.cn/post/6844904040149729294#heading-17)

### 静态库 & 动态库
- 静态库的存在形式主要有两种：.a + .framework
- 动态库的存在形式也是主要有两种：.dylib + .framework

为什么.framework既是静态库也是动态库呢？
- 系统的framework是动态库
- 自定义的framework是静态库

静态库和动态库的区别
- 静态库在链接时会被完整地拷贝到项目中，如果有多个App都用了同一个静态库，那么就会被拷贝多份，浪费内存
- 动态库不会被拷贝多份，在程序运行时动态加载进入内存，多个App共同引用一份内存。
- 动态库在程序运行时加载进入内存，那么在工程项目里动态库是由`cocoaPods`管理的，我们引用动态库，是在`Profile`文件里写进`Pod '动态库'`，然后在终端cd对应的文件，执行`pod install`命令，那么动态库是存在哪的呢？
    - 其实`pod install`之后，动态库已经存在于工程文件的Pod目录下，那么动态库加载进入内存就是加载那部分的文件 - 个人理解，有待验证🌟。

### 通用二进制文件
iOS系统所支持的cpu以及硬件平台发生了很大的变化，为了解决软件在多个硬件平台上的兼容性问题，苹果开发了一个通用的二进制文件格式（Universal Binary）,又称胖二进制（Fat Binary）。
- 苹果公司提出的一种程序代码。能同时适用多种架构的二进制文件
- 同一个程序包中同时为多种架构提供最理想的性能。
- 因为需要储存多种代码，通用二进制应用程序通常比单一平台二进制的程序要大。
- 但是 由于两种架构有共通的非执行资源(代码以外的)，所以并不会达到单一版本的两倍之多。
- 而且由于执行中只调用一部分代码，运行起来也不需要额外的内存，只是包的体积会变大。

## iOS 启动流程和生命周期
### 生命周期
App的生命流程分为三大部分：
1.App的启动流程（pre-main）
2.App的初始化流程（main）
3.App的运行时生命周期

### 启动流程
- 解析info.plist文件，info.plist文件中包含了支持App加载运行时所需要的众多的配置信息，比如可执行文件的路径
- 给应用程序创建沙盒，检查权限信息
- 加载Mach-O可执行文件
- 从Mach-O文件的加载命令中读取dyld路径并加载动态链接器
    - dyld会先配置环境变量
    - 加载共享缓存库
    - 实例化主程序
    - 加载动态库
    - 链接主程序
    - 进行OC的初始化、初始化类、分类的内存布局，加载C++静态函数，Runtime的初始化，load函数的加载
    - dyld从加载命令中读取main函数地址，返回main函数

### 初始化流程（main）
- dyld调用main()
- 调用UIApplicationMain()
- 调用applicationWillFinishLaunching
- 调用didFinishLaunchingWithOptions

[学习链接](https://juejin.cn/post/6844903968837992461#heading-1)

## iOS事件传递、响应链、手势识别
### 响应事件
在UIKit中我们使用响应者对象（`Responder`）处理事件。一个响应者对象一般是`UIResponder`类的实例，它常见的子类包括`UIView,UIViewController,UIApplication`,这意味着我们日常使用到的控件几乎都是响应者，如 `UIButton,UILabel`等等。

在`UIResponder`及其子类中，我们是通过有关触摸`（UITouch）`方法来处理和传递事件`（UIEvent）`,具体的方法有
```swift
open func touchesBegan(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesMoved(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesEnded(_ touches: Set<UITouch>, with event: UIEvent?)
open func touchesCancelled(_ touches: Set<UITouch>, with event: UIEvent?)
```

在 `UITouch` 内，存储了大量触摸相关的数据，当手指在屏幕上移动时，所对应的 `UITouch` 数据也会更新，例如：这个触摸是在哪个 `window` 或者哪个 `view` 内发生的？当前触摸点的坐标是？前一个触摸点的坐标是？当前触摸事件的状态是？这些都存储在 `UITouch` 里面。另外需要注意的是，在这四个方法的参数中，传递的是`UITouch` 类型的一个集合（而不是一个 UITouch），这对应了两根及以上手指触摸同一个视图的情况。

触发（UITouch）方法的参数里传递的是关于UITouch的set，当有多个手指在屏幕上点击或者滑动时，就会有多个UITouch对象来收集这些信息。

### UIResponder和UIControl
- 控件类比如UIbutton等都是继承自UIControl，而UIControl继承自UIView，UIView继承自UIResponder。
- UIControl类一般通过target-action来实现交互

### 确定第一响应者
- 当点击了屏幕，即发生了触摸事件，那么会由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，SpringBoard利用mach port 于App进程进行通信，触发App的Source1回调。
- Source1 触发回调，并调用 `_UIApplicationHandleEventQueue()`进行应用内部的分发。
- `_UIApplicationHandleEventQueue()` 会把 IOHIDEvent处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。
- 包装成UIEvent分发到UIApplication，这一步是会触发RunLoop的Source0事件的，因为这属于App的内部事件。
- 总的来说就是：点击屏幕产生触摸事件，SpringBoard接收到通过port发送消息到当前App的进程，App进程中的Source1监听到系统事件进行回调，将触发事件包装添加到Runloop的Source0中，等待执行将UIEvent事件发送到UIApplication。
![](media/16321370027980/16384390600713.jpg)

### 命中测试确定第一响应者
UIEvent事件发送到UIApplication，再发送到UIWindow，再传递到当前页面的UIViewController，那么在当前页面就需要命中测试来确定第一响应者，确定了第一响应者之后自然就确定了响应链。
![](media/16321370027980/16384391750786.jpg)
关于图中还有一些细节需要先说明：
- 在 检查自身可否接收事件 中，如果视图符合以下三个条件中的任一个，都会无法接收事件：
    1.view.isUserInteractionEnabled = false
    2.view.alpha <= 0.01
    3.view.isHidden = true
- 检查坐标是否在自身内部 这个过程使用了 func point(inside point: CGPoint, with event: UIEvent?) -> Bool 方法来判断坐标是否在自身内部，该方法是可以被重写的。
- 从后往前遍历子视图重复执行 指的是按照 FILO 的原则，将其所有子视图按照「后添加的先遍历」的规则进行命中测试。该规则保证了系统会优先测试视图层级树中最后添加的视图，如果视图之间有重叠，该视图也是同级视图中展示最完整的视图，即用户最可能想要点的那个视图。
- 在 按顺序看看平级的兄弟视图 时，若发现已经没有未检查过的视图了，则应走向 诶？没有子视图符合要求？。

在下图中确定了第一响应者为B后，那么响应链为B -> A
![](media/16321370027980/16384392873409.jpg)

但是在下图中，由于E是D的子视图，但是点击点并不在D的范围内，因此在命中测试时确定的第一响应者并不是E，而是B —— 不明白的重新看一下命中测试的流程。
![](media/16321370027980/16384393366722.jpg)
所以，如果子视图范围超过了父视图，那么有可能会出现确定不对第一响应者，从而无法响应事件。那么解决办法有：
- 重写父视图命中测试的方法：实现时先判断子视图，再判断自身。
- 重写父视图的判断点击点是否在自身范围的方法，从而实现扩大点击范围。

### 通过响应链传递事件
- 在找到了第一响应者之后，整个响应链也随着确定下来了。所谓响应链是由响应者组成的一个链表，链表的头是第一响应者，链表的每个结点的下一个结点都是该结点的 next属性。
- 比如响应链为 B -> A，而且A、B均为UIView的实例对象，那么就会先触发B的touch事件，如果B不处理，就会传递到A，直到有响应者接收此事件或者最后被丢弃。
![](media/16321370027980/16384397255722.jpg)
![](media/16321370027980/16384397529873.jpg)

但是要注意的是，如果有视图是UIControl的子类或者实例对象，当事件传递到它，如果它不接受此事件，但它是不会传递下去的。

### 小结 —— 建立在不使用UIGestureRecognizer 的基础
总的来说，触摸屏幕后事件的传递可以分为以下几个步骤：
- 通过「命中测试」来找到「第一响应者」
- 由「第一响应者」来确定「响应链」
- 将事件沿「响应链」传递
- 事件被某个响应者接收，或没有响应者接收从而被丢弃
- 途中经过UIControl类对象会阻断响应链的传递。

### 如果使用了`UIGestureRecognizer`
当确定了第一响应者后，会将UITouch分发给UIResponder 的 touches 系列方法，同时也会分发给手势识别系统，让这两个处理系统同时工作。
![](media/16321370027980/16384401806359.jpg)
但是要注意的是⚠️：
- 手势识别系列的方法是比touch事件系列的方法触发的更快，而且当手势识别出了之后调用touch事件cancell方法阻断响应链的传递了。
![](media/16321370027980/16384404640657.jpg)

因此，会出现当一个UIButton同时添加了点击手势以及添加了action，那么由于手势识别得更加地快，那么是会调用手势响应的方法。
但是我们也可以实现同时响应两个方法，就是设置手势的属性来改变它的表现`cancelsTouchesInView`，当设置为true之后，手势识别后也不会发送cancell到视图，那么就会同时出发两个响应的方法。

还有一种特殊情况时，父视图添加了手势，子视图是UIcontrol类对象，添加了action，虽然手势识别是更加地快，但是iOS做了特殊的处理，会优先响应子视图的action方法。

[学习链接🔗](https://www.jianshu.com/p/8f85f79b2648)


## Block解析
### ARC 和 MRC 下解除循环引用
Block使用不当，很容易出现循环引用问题。
在ARC下，通过__weak修饰符来消除循环引用，而在MRC下，通过__block修饰符来消除循环引用。
__block修饰符：block不会对外部对象进行强引用，而是传入了指向对象的指针，通过指针的方式的访问对象。

### Block底层解析
```Objective-c
int a=10;
void(^Myblock)(void)=^{
   NSLog("%d",a);
};
Myblock();
```
将上面的block进行clang转译来查看block的底层结构
```Objective-c
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
static void __main_block_func_0(struct __main_block_impl_0 *__cself) {
}
static struct __main_block_desc_0 {
  size_t reserved;
  size_t Block_size;
} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};

struct __block_impl {
  void *isa;
  int Flags;
  int Reserved;
  void *FuncPtr;
};
int main(int argc, const char * argv[]) {
    /* @autoreleasepool */ { __AtAutoreleasePool __autoreleasepool; 
        void(*Myblock)(void)=((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA));
      ((__block_impl *)Myblock)->FuncPtr)((__block_impl *)Myblock);
    }
    return 0;

}
```
对上面转换后的代码进行分析
- `block`代码块被编译成了`__main_block_impl_0`结构体，将`block`的内容作为结构体的构造函数的参数传禁区。
- 在`__main_block_impl_0`结构体上，有以下成员变量
    - `struct __block_impl impl`：保存block的内容信息，比如block的isa指针即block的类型、方法实现、保留字段以及flag；从isa指针中可以看出block其实也是OC的对象。
    - `struct __main_block_desc_0* Desc`：保存block的结构信息，比如block的占用空间大小、保留字段。
    - 还有一个`__main_block_impl_0`结构体的构造函数。
- 在block结构体的构造函数中，我们可以发现block在编译时被赋予为栈Block，但是在实际情况中，我们在控制台查看block的类型，可以发现是堆Block；这是因为，当block捕获了外部变量从全局Block转换为了栈Block，但是系统为了延长Block的生命周期，是自动将栈Block copy到了堆上的。

### Block类型
Block分为三种：全局Block、栈Block和堆Block。
#### 全局Block
在block内部没有捕获外部变量，或者只是捕获了全局变量或者静态变量。
```Objective-c
void (^block)(void) = ^{
       
};
//或者
static int a=10;
void (^block)(void) = ^{
     NSLog(@"%ld",a);  
};
```

#### 栈Block
栈Block存储在栈区，出栈后就会被销毁；
栈Block的特点在于在block内部捕获了外部变量，但是在ARC下，一般不会存在栈Block的，尽管形式上该Block属于栈Block的一种，但是系统默认会将栈Block copy 到堆上。
```Objective-c
//利用__weak修饰的block是不会被copy到堆上的
int b=10;
void (^__weak mblock)(void) = ^{
   NSLog(@"%ld",b);
};
```

#### 堆Block
堆Block存储在堆上，当block的引用计数为0的时候才会被系统销毁，而且在实际开发过程中，基本上都是堆Block，因为堆Block是我们学习的重点。
```Objective-c
int b=10;
void (^mblock)(void) = ^{
   NSLog(@"%ld",b);
};
```

### Block引用外部变量
在没有__block修饰符修饰的情况下
```Objective-c
//新建一个LGTeacher对象
@interface LGTeacher : NSObject
@property (nonatomic, copy) NSString *hobby;
- (void)teacherSay;
@end

LGTeacher* lgter=[[LGTeacher alloc]init];
NSLog(@"%@-%p",lgter,&lgter);
void(^Myblock)(void)=^{
    lgter.hobby=@"test";
    NSLog(@"%@-%p",lgter,&lgter);
};
 Myblock();
 
//输出
<LGTeacher: 0x101218ad0>-0x7ffeefbff200
<LGTeacher: 0x101218ad0>-0x7ffeefbff1e8
```
可以发现，在block外部lgter的指针地址和内部的指针地址是不一样的，但是他们都指向同一块内存空间。这说明lgter在block内部已经是一个全新的变量了。

再来看一下有__block修饰符修饰的情况
```Objective-c
@interface LGTeacher : NSObject
@property (nonatomic, copy) NSString *hobby;
- (void)teacherSay;
@end

__block LGTeacher* lgter=[[LGTeacher alloc]init];
NSLog(@"%@-%p",lgter,&lgter);
void(^Myblock)(void)=^{
    lgter.hobby=@"test";
    NSLog(@"%@-%p",lgter,&lgter);
    lgter=nil;
};
 Myblock();
 
//输出 
<LGTeacher: 0x1007275d0>-0x7ffeefbff1f0
<LGTeacher: 0x1007275d0>-0x7ffeefbff1f0
```
可以看出，在有__block修饰符修饰的情况下：
block外部的lgter指针跟内部的lgter指针是一样的，指向的内存地址也是一样的，因此可以认为，这里面存在着指针传递。

#### clang解析__block
在没有__block修饰符修饰的情况下：
可以看出，在Block结构体内部持有一个成员变量lgter，外部的lgter对象作为参数传进Block结构体的构造函数中，在构造函数中将外部的lgter赋值给内部的lgter，因此验证了上文中在__block修饰的对象，在block内部中的和外部中的对象不是同一个，只是他们指向的内存地址是一样的。
![](media/16321370027980/16385983018398.jpg)

再看一下有__block修饰符修饰的情况下：
使用__block修饰符修饰的对象在Block结构体内部被编译成了`__block_byref_lgter_0`结构体，在block的构造函数中，把参数`_block_byref_lgter_0`结构体指针的`__forwarding`赋值给block中属性`_block_byref_lgter_0`，而`__forwarding`又是一个指向自己的`__block_byref_lgter_0`指针，简单来说：就是一种指针传递。
![](media/16321370027980/16385984725851.jpg)

总结
- __block修饰的对象是指针传递，无论__block变量配置在堆上还是栈上都能够正确的访问__block变量。
- 没有用__block修饰的对象是值传递，block内部的变量和外部的变量不是同一个指针，只是值相同或者说指向的对象相同

### copy
当我们在声明属性时，用copy修饰符来修饰Block，那么默认会对Block进行强引用，而且声明的Block会自动copy 到堆上。

我们看看系统是怎么将Block复制到堆上的。
系统复制Block到堆上，调用的是`Block_copy`方法。
```Objective-c
void *_Block_copy(const void *arg) {
    //block底层正在的结构是一个Block_layout
    struct Block_layout *aBlock;
    if (!arg) return NULL;
    aBlock = (struct Block_layout *)arg;
    //block是否需要释放
    if (aBlock->flags & BLOCK_NEEDS_FREE) {
        // latches on high
        latching_incr_int(&aBlock->flags);
        return aBlock;
    }
    //全局block直接返回
    else if (aBlock->flags & BLOCK_IS_GLOBAL) {
        return aBlock;
    }
    else {
        // 栈 - 堆 (编译期)，栈block的拷贝，堆block都是从栈拷贝过来的
        size_t size = Block_size(aBlock);
        //开辟堆block内存
        struct Block_layout *result = (struct Block_layout *)malloc(size);
        if (!result) return NULL;
        //把栈block拷贝进堆block中
        memmove(result, aBlock, size); 
#if __has_feature(ptrauth_calls)
        // Resign the invoke pointer as it uses address authentication.
        result->invoke = aBlock->invoke;
        //省略...
        result->flags &= ~(BLOCK_REFCOUNT_MASK|BLOCK_DEALLOCATING);    // XXX not needed
        result->flags |= BLOCK_NEEDS_FREE | 2;  // logical refcount 1
        //获取copy函数，其实是对对象的拷贝
        _Block_call_copy_helper(result, aBlock);
        // Set isa last so memory analysis tools see a fully-initialized object.
        result->isa = _NSConcreteMallocBlock;
        return result;
    }
}
```
分析
- 可以看到如果Block是全局Block，那么会直接返回
- 但是如果Block是一个栈block，那么就会在堆区malloc开辟内存
- 在`_Block_call_copy_helper`函数中再调用`_Block_object_assign`方法改变外部对象的引用计数或内存拷贝。

_Block_object_assign
```Objective-c
void _Block_object_assign(void *destArg, const void *object, const int flags) {
    const void **dest = (const void **)destArg;
    switch (os_assumes(flags & BLOCK_ALL_COPY_DISPOSE_FLAGS)) {
      //对象 引用计数加1
      case BLOCK_FIELD_IS_OBJECT:
        _Block_retain_object(object);
        *dest = object;
        break;
        //block类型，进行_Block_copy
      case BLOCK_FIELD_IS_BLOCK:
        *dest = _Block_copy(object);
        break;
      case BLOCK_FIELD_IS_BYREF | BLOCK_FIELD_IS_WEAK:
      //__block修饰的对象 会拷贝整个结构体进堆区
      case BLOCK_FIELD_IS_BYREF:
        *dest = _Block_byref_copy(object);
        break;
      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT:
      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK:
        *dest = object;
        break;
      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_OBJECT | BLOCK_FIELD_IS_WEAK:
      case BLOCK_BYREF_CALLER | BLOCK_FIELD_IS_BLOCK  | BLOCK_FIELD_IS_WEAK:
        *dest = object;
        break;
      default:
        break;
    }
}
```
分析
- 如果外部变量是对象，_Block_retain_object使外部对象引用计数加1，所以在block内使用外部变量，比如self就需要使用弱引用，否则block内部会强引用self使得引用计数加1。栈Block引用外部对象会让外部对象引用计数加1，而栈Block复制到堆上会让对象的引用计数再加1。
- 如果外部变量是block类型，_Block_copy
- 如果外部变量是__block修饰的，__block修饰的对象会被编译成一个block_byref结构体，那么会拷贝整个结构体进堆区。


### __weak
我们知道当block引用的外部变量是对象，会被强引用；Block成员变量声明时会使对应的引用计数加1，栈Block被复制到堆上时，对象的引用计数又会加1，那么为了不让对象被Block强引用，可以使用__weak来修饰。

```Objective-c
struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* Desc;
  NSString *__weak str;
  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *__weak _str, int flags=0) : str(_str) {
    impl.isa = &_NSConcreteStackBlock;
    impl.Flags = flags;
    impl.FuncPtr = fp;
    Desc = desc;
  }
};
```
可以看出，在__weak修饰符修饰之后，Block在声明成员变量时也会带上__weak修饰符，表示弱引用，而栈Block被复制到堆上时，也不会让对象的引用计数加1。

[学习链接🔗](https://juejin.cn/post/7024424400170532901#heading-3)


## 优化
### 二进制重排实现启动优化
引用了虚拟内存后，每个进程会有一大片连续的内存空间，但实际上是虚拟的> ，当访问进程的虚拟地址时，会通过映射表映射到真实的物理地址。

- 而应用在被加载到内存时，并不会将整个应用加载到内存中，只是会将用到的加载到内存。
- 比如访问虚拟地址A，但是在映射表中发现对应的页不在内存中，那就就会阻塞当前进程，触发缺页中断。
- 当缺页中断被触发时，操作系统会从磁盘中重新读取这页数据到物理内存上，然后更改映射表中虚拟内存的指向，如果当时内存满了，那就就会根据页面置换算法，选择一个牺牲页置换出去，然后加载需要的那一页进入到内存中。

从上面的描述中可以发现，发生一个`page fault`即缺页中断会阻塞进程，缺页中断发生过多会对性能产生很大的影响的。
而且在iOS系统上，对于生产环境的应用，当产生缺页中断进行重新加载时，iOS系统还会对其进行一次签名验证，因此，iOS生产环境的应用page fault所产生的耗时会更多。

#### 二进制重排原理
加快App的启动时间，其实在于减少启动期间发生的缺页中断`page fault`。

减少App启动时的缺页中断，那么就意味着将App启动所需要调用的方法都排在最前面的页面中，那么就可以大大减少缺页中断的次数。

在iOS中，函数在mach-O文件中的位置是由编译顺序决定的而非调用顺序

我们需要做的就是收集App启动时所要调用的全部函数，然后将他们排在Mach-O文件的最前面，从而减少缺页中断的次数。

#### 怎么修改符号的顺序
- Xcode使用的链接器叫做ld，ld中有一个参数叫做Order File，我们可以通过这个参数配置一个order文件的路径。
- 在这个order文件中，将App启动所需要的全部函数按顺序写在里面。
- 当工程build的时候，Xcode就会读取这个文件，打的二进制包就会按照文件中的符号顺序生成对应的mach-O文件。

#### 那么怎么收集启动所需要的函数呢？
- hook objc_MsgSend ( 只能拿到 oc 以及 swift 加上 @objc dynamic 修饰后的方法 ) 
    - load方法是根据函数地址直接调用的，不走消息发送机制
    - C++函数 也是不走消息发送机制的
    - swift中的函数在编译器就已经确定了，一般都是静态调用，除非是有@objc 和 @dynamic 修饰符修饰的，那么就会走消息发送机制
- 静态扫描 macho 特定段和节里面所存储的符号以及函数数据 . (静态扫描 , 主要用来获取 load 方法 , c++ 构造
- clang 插桩 ( 完美版本 , 完全拿到 swift , oc , c , block 全部函数 )

##### clang插桩
- 通过静态插桩在编译器就在每一个函数内部二进制源数据添加hook代码（ 我们添加的 __sanitizer_cov_trace_pc_guard 函数）来实现全局的方法hook的效果。
- 那么每当执行函数，第一步都会执行插桩的方法，我们知道执行函数时，寄存器会先保存当前函数下一条指令的地址，那我们就通过访问寄存器来获取当前指令的地址。
- 通过获取到的函数内部的指令地址来找到函数符号，从而得到我们想到的函数符号。
- 将App启动之前访问到的函数符号收集起来，按照顺序写进order文件，那么重新编译时链接器就会按照这个文件中的符号顺序来链接出mach-O文件。

##### 那么怎么验证是否真的改变了Mach-O文件的符号顺序呢？
这时候就要用到`Link Map`了。
`Link Map`是编译期间产生的产物，它记录了二进制文件的布局，其中存储了所有符号顺序，在 # Symbols: 部分，通过这个文件，我们可以看到编译顺序是否按照修改后的来。（链接器链接二进制文件是根据编译顺序来的）

##### 坑点
- 多线程问题，利用苹果底层的原子队列来解决问题。
- 插桩时可能会遇到死循环的问题。
- load方法被屏幕掉了。

[学习链接🔗](https://juejin.cn/post/6844904130406793224#heading-29)

## 框架源码解析
### YTKNetwork
[YTKBaseRequest](media/16321370027980/YTKBaseRequest.pdf)
![YTKBaseRequest](media/16321370027980/YTKBaseRequest.png)

### YTK的批量请求
- `YTKBatchRequestAgent`内部维护一个数组`requestArray`，专门用于保存请求。
- 当有新的请求发起时，那么就会先加入到`YTKBatchRequestAgent`管理的数组下
- 然后遍历该数组，调用`request`的start方法
- 后面就走到了上图的分析过程了。

### YTK的链式请求
- `YTKChainRequestAgent`对象同样维护着一个用于保存请求的数组
- 当有新的请求发起时，先判断当前数组中是否还有未完成的请求，先完成数组中的请求，再把当前请求加入到数组中
- 链式请求中是根据维护的请求数组，以及一个保存index下标的变量来实现。

[学习链接🔗](https://juejin.cn/post/6844903487721963527#heading-7)

## 对于weak属性的理解
weak属性 - 我们理解为非拥有关系。为这种属性赋新值时，设置方法既不保留新值，也不释放旧值。

** 既不保留新值，也不释放旧值 **
可以理解为：self以weak指针指向对象，该对象的初始值是A，后重新赋值为了B，那么不保留新值时，对象不会强引用着B，不释放旧值的意思是：改对象被重新赋值为了B，对A是没有影响的，因为本身不存在引用，所以也就没有释放。

当我们从xib或者storyboard中拖出控件View到工程文件里，我们会发现这个View会被声明为weak属性。

** 声明为weak属性的view不是会立马被释放的吗？那为什么还是会声明为weak属性的呢？ **
当我们拖控件进入xib或者storyboard时，这时就相当于执行了addSubview这个方法，说明此控件已经成为了根view的子控件了，那么根view在管理子控件时，是将所有的子控件统一放进subViews数组里的，如下：

```Objective - c
@property(nonatomic,readonly,copy) NSArray<__kindof UIView *> *subviews;
```

subviews数组是声明为copy属性了，所以相当于根View对subviews有了一个强引用，因此拖出来的子控件view声明为weak属性是没有问题的。

** 既然这样，那么将拖出来的子控件属性改为strong吗？ **
答案是可以的，改为strong，相当于多了一个引用，引用计数从1变为2而已。

** 那weak属性是怎么实现的呢？ **
Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个哈希表，Key是所指对象的地址，Value是一个数组，存储的是weak指针的地址。（比如：A弱引用着B，那么在weak表里面，Key就是B的地址，Value就是包含A在内的地址数组）

** 实现原理可以概括为以下三步 **
1.初始化时，runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址
2.添加引用时，objc_initWeak函数会调用objc_storeWeak()函数，objc_storeWeak()函数的作用是指针重定向，创建对应的弱引用表。（比如：先初始化一个weak变量A，这时objc_initWeak就是初始化一个weak指针指向A的地址，然后对象B捕获了A，相当于B弱引用了A，这是objc_initWeak就会调用objc_storeWeak()函数，改变weak指针的指向，变为从B指向A）
3.释放时，调用clearDeallocating函数。clearDeallocating函数首先会根据对象地址获取到weak表里的所有weak指针的数组，然后遍历这个数组把其中的数组都置为nil，最后还将这个表项从weak表中删除。

## @synthesize 和 @dynamic 的区别
** @property **
@property 声明的属性 会自动生成 setter方法、getter方法、实例变量

** @synthesize **
@property声明的属性，我们可以重写它的setter方法或者getter方法，但是我们不能同时都重写他们的setter和getter方法
而如果将** @property **声明的属性加上** @synthesize **修饰，那么我们可以同时重学属性的setter方法和getter方法

** @dynamic **
在** @property ** 声明的属性下，再用** dynamic **修饰，这是在告诉编译器不需要帮此属性生成setter和getter方法，需要我们手动去实现，如果没有实现，在运行时是会崩溃的。而且** @dynamic **声明之后，不仅需要手动实现setter方法和getter方法，如果需要实例变量，也是需要我们自己去补全的。

## 动态绑定
在OC中动态绑定是用** Runtime ** 实现的。

我们知道在分类中是无法添加属性的，那如果我们不想继承这个类，但还想为这个类添加新属性的话，我们可以利用** Runtime ** 动态绑定来实现。

** Runtime的动态绑定 **
其实相当于重写属性的setter方法和getter方法
在setter方法里，调用objc_setAssociatedObject,
在getter方法里，调用objc_getAssociatedObject。
这两个方法是根据一个Key关键字去找到对应的数据的。

``` Objective - c
//ViewController+Objc.m文件
#import "ViewController+Objc.h"
#import <objc/runtime.h>

static NSString * const themeKey = @"theme_key";

@implementation ViewController (Objc)

- (NSString *)themeText {
    return (NSString *)objc_getAssociatedObject(self, &themeKey);
}

- (void)setThemeText:(NSString *)themeText {
    objc_setAssociatedObject(self, &themeKey, themeText, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

@end
```

## Category、Extension和继承
** Category **
Category，术语称为类别，类别的用处还是很大的，主要总结为以下两点：
1.在一个类上新增方法，但是又不想继承这个类，那么就可以用到类别Category，类别允许我们在不继承类的情况下给该类新增方法，但是不可以新增属性。
2.如果想要复写原类中的一个方法，那么我们可以在类别中新增同名的方法，那么调用的时候只会调用类别实现的方法，类别的优先级是比原类要高的。

** Category 和 Extension 区别 **
1.形式上，Extension是匿名的Category
2.Extension里声明的方法需要在main implementation中实现，而Category中不作要求
3.Extension可以添加属性，Category上是不可以的
4.Category和原有类的耦合度更低一些，声明和实现都可以写在单独的文件里，但就是只能为已定义类增加Method，而不能加入实例变量
5.使用Extension可以更好的封装类，在.h文件中能看到的都是对外的接口，其余的实例变量和对内的@property等都可以写在Extension里，这样类的结构更加清晰。


##  为什么代理要用weak修饰，代理中的dataSource和delegate有什么区别，Block和代理有什么区别 
** 代理用weak修饰 **
这样做的话引用计数不会加一，可以避免循环引用进而发生内存泄露的问题。

** 代理中的dataSource和delegate有什么区别 **
两者都是代理，不同的是两者的职责不一样。dataSource是数据源，是要提供View展示所需要的数据的，而Delegate偏重于用户操作的回调。

** 什么时候用Block，什么时候用代理 **
Block相对于Delegate来说，代码更清晰易懂，直观明了，适用于回调较少的情况，而代理适用于方法较多，回调较多的情况。

## id 和 NSObject* 的区别

** 为什么id类型的对象在声明时不需要加 *，而类似于NSObject等的对象在声明时需要加上 **
- 这是因为id的本质是结构体指针，可以理解为已经内涵了 * 了，而OC中对象的本质是结构体，所以我们在声明时需要加上 *

** id 和 NSObject * 的区别到底在哪里？ **
1. OC中的基类除了NSObject，还有NSProxy虚类，因此id 包括的范围是比 NSObject * 更大的。
2. id声明的对象是动态数据类型，而NSObject * 声明的对象是静态数据类型。
    - id声明的变量在编译时不会做类型检查，而NSObject * 声明的对象在编译时会做类型检查
    - 静态类型在编译时就知道变量的类型了，那么在编译时，如果该对象调用了本不属于这个类以及父类的方法，那么就会直接报错。而id对象是动态类型，相对来说，在编译时由于无法确定变量的类型，那么尽管 声明对象的格式为 id obj = @123; 也不会将obj对象默认为NSNumber类型的，因此在编译时尽管调用了不属于NSNumber的方法，也是不会编译报错的，只有在运行时找不到这个方法，那么就会crash
[🔗](https://www.jianshu.com/p/c537db1f7cb5)

## 拓展 —— NSProxy
** NSProxy **
NSProxy 是一个虚类，它也是一个基类，遵守了NSObject协议。
```Objective - c 
@interface NSProxy <NSObject> {
    Class	isa;
}
```
而通过看文档，我们可以知道，NSProxy是一个抽象的超类，为充当其他对象或者不存在的对象的代理对象的定义API，通常，发送给代理的消息被转发到实际对象。
![](media/16321370027980/16326626067394.jpg)

** NSProxy的用法 **
NSProxy实现了包括NSObject协议在内基类所需的基础方法，但是作为一个抽象类的基类，并没有提供初始化方法。它接收到任何自己没定义的方法都会产生一个异常。因此，作为NSProxy的子类，首先必须要提供初始化方法，其次还要实现** forwardInvocation： **方法和
** methodSignatureForSelector： **方法来处理自己没有实现的消息。这就是NSProxy的主要功能，负责把消息转发给真正的target代理类。NSProxy正是充当代理的作用。


** NSProxy的使用场景 **
1.多继承
> OC本身是不支持多继承的，多继承的意思是类C同时继承了类A、B，同时有类A、B的特性。

虚基类本身就是为了解决继承问题而生的，而OC的动态特性可以让我们用NSProxy来实现多继承；

2.解决NSTimer循环引用的问题
我们知道NSTimer在创建时是要传入一个target参数的，一般都是传入self，那么NSTimer会强引用着self，那如果self本身就强引用着NSTimer，那么就会出现循环引用的问题。
而我们在解决NSTimer循环引用的问题是将self弱化，那么NSTimer就不会强引用到self。

而现在我们在解决NSTimer循环引用问题时，可以有另一种方案，那就是利用NSProxy来实现，
NSProxy充当一个消息转发的功能，NSProxy持有一个weak的target，而NSProxy对象就是NSTimer持有的对象，当发送消息到NSProxy对象时，NSProxy对象就将此消息转发给target，解决了循环引用的问题。

** NSProxy 和 NSObject 的区别 **
虽然 NSProxy 和 NSObject 都定义了-forwardInvocation:和-methodSignatureForSelector:这两个方法，但是两者的内部实现是不一样的。

** 对于 NSObject 而言 **
接收到消息后先到自身的方法列表那里去找看是否找到，如果找不到，那么就沿着继承体系往上查找，如果还找不到，那么就先后经过 +resolveInstanceMethod:（看是否能动态地添加一个新方法），-forwardingTargetForSelector:（消息重定向），再到-methodSignatureForSelector:/-forwardInvocation:（进行消息转发）

** 对于 NSProxy 而言 **
接收到自身未定义的方法就会直接进行消息转发，先查询methodSignatureForSelector：，看是否得到有效的方法签名，如果有再到-forwardInvocation:进行消息转发。
相比来说，NSProxy 的 消息转发进行得会更加得快，这也体现了 NSProxy 作为代理的抽象基类的优势之处。

** 还有一个值得注意的区别是 **
对于以下三个方法：

- (BOOL)isKindOfClass:(Class)aClass;
- (BOOL)isMemberOfClass:(Class)aClass;
- (BOOL)respondsToSelector:(SEL)aSelector;

如果分别进行 NSProxy 和 NSObejct 的消息转发，我们可以发现，NSProxy是可以正常进行消息转发的，而对于 NSObject 来说，是默认没有走消息转发的，可以理解为 NSObject 只是看自己的方法列表里有没有对应的方法，有就return YES，没有就return NO，而不会走消息转发。

[文章学习🔗1](https://juejin.cn/post/6847902216209039367)
[文章学习🔗2](https://www.jianshu.com/p/b0f5fd3e4b7c)

## 消息处理之performSelector 与 直接调用方法 的区别
iOS中调用方法的方式有很多种，而其中的两种就是 performSelector 和 直接调用。

** 两者有区别吗 **
答案是有的。
performSelector：它可以对对象传递任何一个方法，而且不需要在编译的时候就已经声明了这些方法。因此，可以看出：performSelector 调用方法 与 直接调用 的区别在于 runtime的特性。
简单来说：就是[A performSelector:方法]，尽管这个方法在A中是还没有声明的，编译的时候也不会报错，直到运行时真的找不到这个方法，那么就可能会出现程序崩溃。
而直接调用方法，如果这个方法在调用类中并没有声明，那么就会有编译报错。

[学习🔗](https://www.jianshu.com/p/672c0d4f435a)

## NSMethodSignature
在 Runtime 消息传递的第三步中消息转发 调用到了两个方法：methodSignatureForSelector:/-forwardInvocation:，而在methodSignatureForSelector这个方法里是返回一个NSMethodSignature对象，** 记录着method的返回值、参数等类型信息，然后被包装成一个NSInvocation对象，作为forwardInvocation：方法的参数输入。*

NSMethodSignature 其实 就是作为 NSInvocation对象的中转站。
[学习🔗](https://www.jianshu.com/p/70a8b3f62107)

## 使用系统的Block，需不需要考虑循环引用的问题
在我们使用UIView的动画或者GCD时，都会接触到系统自带的Block，那我们是不需要考虑循环引用的问题的，因为在Block中捕获了self，但是self本身是没有持有该Block的，因此不会出现循环引用的问题。

## 内存的五大分区
bss段、数据段、代码区、栈区、堆区
1. bss段（bss segment）
    - bss段通常是指用来存放程序中未初始化的全局变量和静态变量的一块内存区域，比如Int a；那么a就会被放进bss段，而当a = 1；初始化之后，a就会从bss段转到数据段。
2. 数据段：
    - 通常用来存放已经初始化之后的全局变量 和 静态变量
3. 代码区：
    - 通常用来存放程序的可执行文件。由于程序的可执行文件是被频繁地访问到的，为了不用每次都拷贝到内存中，那么在程序运行之前就已经申请好了一份。
4. 栈区：
    - 通常是用来存放程序中临时创建的局部变量
5. 堆区：
    - 通常是用来存放进程运行中被动态分配的内存段，一般我们alloc之后的对象都是被分配到了堆区。
![](media/16321370027980/16352642887216.jpg)
- 栈区分配地址是向低地址分配的，而堆区分配地址是向高地址分配的。一般栈区和堆区的地址空间为0x100 ～ 0x800

- 下面的变量str和array都是被分配在了栈上，变量str和array的地址是指向栈的。
- 而对应栈上的数据也是一个指针，str的是指向常量区的指针，array的是指向堆区的指针。
- 当变量要被回收的时候，栈中的str和array就会被系统自动释放掉，那么就没有指针指向常量区和堆区的数据了，编译器就会自动调用release方法来回收对象。
- release方法的操作：将该对象的引用计数 -1，然后判断该引用计数是否为0，为0的话就会调用对象的dealloc方法。
- dealloc方法的操作：清空引用计数、清空weak指针，删除关联对象。

``` Objective-c
int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSString *str = @"123";
        NSArray *array = @[@"asd",@"a"];
    return 0;
}
```
## static 关键字
** static 修饰局部变量 **
- static修饰的变量只会初始化一次，而且每次访问的内存地址都是一样的

```Objective -c
- (void)test {
    //每次调用test方法时，staticValue的内存地址都是一样的，只初始化一次
    NSInteger i = 0;
    i++;
    
    static NSInteger staticValue = 0;
    staticValue++;
    
    NSLog(@"i = %ld, s.value = %ld", (long)i, (long)staticValue);
}
```
- static修饰的局部变量只在作用域内有效，上段代码中的变量staticValue只在test这个函数里有效，在别处是无效的。

** static 修饰全局变量 **
- static 修饰全局变量时，作用域仅限于当前文件，外部类是无法访问到的，而没有static 修饰的全局变量，外部类是可以访问到的，只需利用extern关键字

** 总结 **
- static修饰局部变量时：该变量只会被初始化一次，而且作用域仅限于当前范围，但作用在于可以延长该变量的生命周期，一般等到程序运行结束才会被释放回收
- static修饰全局变量时：该变量作用仅限于当前文件，外部类是无法访问到的。

## Tagged Pointer
- 从苹果官方介绍来看， Tagged Pointer 被设计的目的是用来存储较小的对象，例如 NSNumber、NSDate、NSString 等；
- 从Tagged Pointer指针中已经可以确定对象的类、数据类型已经数据的值；
- Tagged Pointer只是一个伪指针

![](media/16321370027980/16352652860456.jpg)
```Objective-c
NSNumber *number1 = @(1);   // number1: 0xb000000000000012
//b 是指 1011; 从左边起，第一个1其实就是标识位，1则标识为是Tagged Pointer指针，后面的011则表示NSNumber这个类，其他类则会有不同的标识，而最后面的12中的1则表示数值，2表示NSNumber里的数据类型，是short还是long等等
```
** Tagged Pointer的好处 **
- Tagged Pointer可以减少内存的开销以及提高效率；
- 减少内存开销：对于一个NSNumber的对象，** 在没有Tagged Pointer之前 **，内存分配是这样的：在栈分配了8字节，然后栈的数据其实也是一个指针，指向堆区，堆里面存的是isa指针以及对象的值，占16字节（isa指针8字节，对象的值也被分配了8字节 - iOS的内存对齐是16字节），那么总共就分配了24字节；** Tagged Pointer之后 **，对象其实就是一个伪指针，8字节里面已经包含了数据。
- 提高效率：objc_msgSend 执行前会先判断该对象是不是Tagged Pointer，是的话就直接返回；不是的话再进行消息发送机制。

[学习链接🔗](https://cloud.tencent.com/developer/news/717577)

## 线程安全
- 线程安全是多线程访问时，采用了加锁的机制。当一个线程访问某个类的数据时，其他线程不能访问直到该线程访问结束，其他线程才可访问。
- 线程不安全是多个线程同时访问和修改资源时，可能会出现数据错乱和数据安全问题，甚至会导致程序崩溃。







