# 算法
[TOC]

## 整除
若整数b除以非零整数a，商为整数，余数为0，那么我们就可以称为b能被a整除（或说a整除b），b是被除数，a是除数。

## 动态规划
常见的问题有：
- 动规基础
- 背包问题
- 打家劫舍
- 股票问题
- 子序列问题

解题方法：
- dp数组以及下标的含义
- 递推公式
- dp数组如何初始化
- 遍历顺序
- 打印dp数组

[动态规划详细学习]([「代码随想录」动态规划专题精讲（v1.2）](media/16287800652806/%E3%80%8C%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98%E7%B2%BE%E8%AE%B2%EF%BC%88v1.2%EF%BC%89.pdf)

## 回溯法
回溯法也可以叫做回溯搜索法，它是一种搜索的方式。
回溯和递归是相辅相成的，回溯是递归的副产品，只要有递归就会有回溯。

回溯法其实是纯暴力搜索，它的本质是穷举，穷举所有可能，然后选出我们想要的答案，因此它并不是什么高效的算法。

那既然回溯法并不是高效的算法，那为什么还要使用它呢？

因为对于一些问题，能暴力解出来已经很不错了。

那是什么问题？只能暴力求解呢？
- 组合问题：N个数里面按一定规则找出k个数的集合
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 切割问题：一个字符串按一定规则有几种切割方式
- 棋盘问题：N皇后，解数独等等
- 子集问题：一个N个数的集合里有多少符合条件的子集

那怎么理解回溯算法呢？
其实我们可以将回溯算法抽象地理解为树形结构，回溯法解决的都是在集合中递归查找子集，集合的大小就决定了树的宽度，而递归的深度就决定了树的高度。

递归是要有终止条件的，所以必然是一棵高度有限的N叉树。

举个🌰：
在组合问题中，在[1,2,3]集合中找出两个数的集合
![](media/16287800652806/16290893235512.jpg)

回溯法的模版
在回溯算法中，一般命名的模版是backtracking

- 回溯算法的终止条件：
我们将回溯算法理解成了抽象的树形结构，那么算法的终止条件就应该是到达了树的叶子结点，将叶子结点的信息保存起来，结束本层递归。

- 回溯算法的遍历过程：
回溯算法一般是在集合中递归搜索中，集合的大小构成了树的宽度，递归的深度构成了树的高度。
![-w1216](media/16287800652806/16290982212308.jpg)
伪代码：
```Objective-c
for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
处理节点;
 backtracking(路径，选择列表); // 递归
回溯，撤销处理结果
}
```
for循环就是遍历集合区间，可以理解为一个节点有多少个子节点，就遍历多少次。
从图中可以看出，for循环可以理解为横向遍历，backtracking可以理解为纵向遍历，这样就把这棵树遍历完了，通常，搜索叶子节点就是找的其中一个结果了。

综上所述：
回溯算法的模版为：
```Objective-c
void backtracking(参数) {
 if (终⽌条件) {
存放结果;
 return;
 }
 for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩）) {
处理节点;
 backtracking(路径，选择列表); // 递归
回溯，撤销处理结果
 }
}
```

尽管回溯法是暴力搜索，但是它也有可优化的空间，那就是对上述的算法进行剪枝优化。
举个🌰：
当n=4，k=4时，第二层的取2开始遍历是没有意义的，这种就需要去剪枝，从而达到优化的效果。
![-w1134](media/16287800652806/16291003853909.jpg)

那么怎样去剪枝呢？
我们知道横向遍历的是树的宽度，这是有集合的个数决定的，也就是for循环里面的条件决定的。
因此，我们进行剪枝的操作是要在for循环里进行操作，去限制i可增的最大空间。
进一步解析：
要获取的结果的集合里元素的个数是k，而path数组保存的是已经获取到的元素
那么k-path.count就得出还要获取的元素个数A，
假如n=4，A=2，那么startIndex最多可以从3开始，那么startIndex <= (n-A+1)
```C
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) // i为本次搜索的起始位置
```
优化后整体代码如下：
```C++
private:
 vector<vector<int>> result;
 vector<int> path;
 void backtracking(int n, int k, int startIndex) {
 if (path.size() == k) {
 result.push_back(path);
 return;
 }
 for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化
的地⽅
 path.push_back(i); // 处理节点
 backtracking(n, k, i + 1);
 path.pop_back(); // 回溯，撤销处理的节点
 }
 }
```
[回溯算法学习]([「代码随想录」回溯算法精讲（v1.1）](media/16287800652806/%E3%80%8C%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95%E3%80%8D%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%B2%BE%E8%AE%B2%EF%BC%88v1.1%EF%BC%89.pdf)