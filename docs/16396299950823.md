# 自我介绍
面试官好，我叫叶嘉轩，现在就读于广东工业大学，是一名计算机科学与技术专业的大三在校生。我是在大一下学期的时候开始接触的iOS开发，当时是参加了学校里的TopView工作室的iOS招新，从而开始对iOS方面的了解、学习。在这一年多的学习时间里，主要是在维护工作室的项目，对一些bug的修复以及对项目的优化，平时会看看书或者上掘金、简书去学习一些技术博客，自己也会对学过的知识点进行总结，将一些比较有价值的知识点会发布到自己的博客上。以上就是我的自己介绍，谢谢！


# 项目有没有用到解耦的
可以将一下将MVC模式转换为MVVM/MVP模式，将网络请求，一些交互转移到了VM层/P层，让C层没那么臃肿，同时还能实现解耦。
或者可以讲一下组件化，自定义View，减少C层跟V层的耦合度。

项目中有些地方会讲MVC模式转换为MVVM模式，将本来堆积在C层中的网络请求部分以及交互更新model层数据的业务抽离到了ViewModel层，Controller层只需要调用一下ViewModel中暴露出去的接口，就可以进行网络请求，这样可以大大减少Controller层的臃肿，以及降低耦合度。

项目中还有些地方是使用了自定义的View，在自定义View上添加好对应的子View，做好布局，Controller层在布局的时候只是实例化自定义View的对象并传入对应的位置、大小，就可以将整个View创建出来，降低了耦合度。

# MVC、MVP、MVVM的区别

# 项目中的性能优化
- 可以讲一下利用静态clang插桩来实现二进制重排从而加速App的启动。
    - 这部分可以说多点感觉
    - 由于可执行文件的链接顺序是按照编译顺序链接的，并不是按照调用顺序链接的，那么就有可能出现App启动所需要调用的函数分散得很远，从而需要更多的缺页中断次数，才能完成App的启动。而缺页中断是需要将数据从硬盘加载到内存，是非常耗时的，那么减少缺页中断的次数可以大大加快App的启动时间。
    - clang插桩就是在编译时给程序的每个函数的开头都插入一个函数，那么在插入的函数被调用时，就会收集PC寄存器里下一条指令的地址，根据获取到的地址得出函数符号，那么就可以顺利收集到App启动所需要的函数。
    - 将收集到的启动所需要的函数写入link order文件，这个文件是链接器在链接时会根据文件里的符号顺序进行链接的，那么这样就可以实现将启动所需要的符号都排在了可执行文件的前面。下次，App再次启动的时候就可以大大加快启动速度。
    - App启动的缺页中断次数是可以通过Instruments工具里的system trace来观察到的。
- 减少离屏渲染的问题
    - 这里可以先不说：只是复习的时候整理一下 ————————— 离屏渲染的概念：在正常渲染流程中，GPU渲染完之后将数据输出到FrameBuffer即帧缓冲区，当VSYC垂直同步信号到来时，显示器会扫描帧缓冲区内的数据然后显示出来，但是有时面临一些限制，无法将渲染结果直接写进帧缓冲区里面，那么就需要额外创建一个缓冲区OffScreen Buffer，将数据暂时存放到离屏缓冲区内，完成将结果切换到frame Buffer里，这个过程就叫做离屏渲染。
    - 这里开始说：当TableView中的每一个cell都会有imageView 设置了圆角，边框并且调用了裁剪方法，那么这时候就会触发离屏渲染，每一个cell都会触发离屏渲染，那这样对App的性能损耗是非常大的。解决办法就是：利用贝塞尔曲线将显示的样式绘制出来，赋值到CAShapeLayer的path属性上，将layer添加到View的layer上，这样可以在不产生离屏幕渲染的情况下实现圆角的效果。
- 清理内存泄漏的问题
    - 在项目里比较常见到的内存泄漏主要是Block、delegate以及NSTImer。
    - 当将Block声明为类的属性时，Block在实现时又捕捉到了self，那么就会有循环引用问题，这种情况可以弱化self来避免循环引用问题
    - delegate在声明时如果使用了strong修饰，也是会存在循环引用问题，这种情况就得将strong修饰符改为weak修饰符
    - 而NStimer就容易出现强引用跟循环引用问题，在主线程初始化的NSTimer默认是会被添加到主线程的RunLoop上的，那么RunLoop就会对当前timer有一个强引用，如果timer在初始化时使用了addtarget的方式，那么timer也会强引用着self，这样就很容易出现强引用造成self释放不了或者循环引用的问题。这种情况就需要在viewdidappera方法或者重写dealloc方法里对计时器设置为不可用并置为nil，对于循环引用，在NStimer初始化时可以使用block的形式初始化，或者利用NSProxy抽象基类来实现消息转发。
    - 在Xcode的Instruments工具里，有个Leaks的工具可以检测整个工程项目下的内存泄漏问题。
    - 或者在项目中导入MLeaksFinder第三方框架，该框架发现出现内存泄漏问题时就会弹出弹窗通知哪里出现了内存泄漏问题。
- UITableView的优化
    - cell的复用。当tableView上要展示多个cell时，如果每个cell都是新创建出来的，那么会很占内存。解决办法就是利用cell的复用，系统会根据tableViwe的高度以及cell的高度去判断创建多少个cell，以后tableView在滑动时，就复用之前创建的cell。（比如当前页面展示6个cell，那么一般会创建7个cell）
    - 尽量少在cellForRowAtIndexPath中设置数据，因为假如有100个cell，那么会给每个cell都设置了数据，但是显示在屏幕上往往就几个cell，那么这样就会很耗费加载时间。可以在willDisplayCell里进行数据的设置，那么就只会在cell显示的时候才会给当前cell设置数据。
    - 提前计算好cell要显示的数据并做好缓存。
    - 加载网络数据，下载图片时使用异步加载，并且做好缓存
    - 当只是更新某些cell的数据时可以使用局部更新。
        - reloadSection实现局部更新
        - 或者使用iOS13以后的Data Source新特性：基于Diffable的局部更新
        - reloadSection实现局部更新是将cell删了重新复用一个，而新特性是在之前的基础上进行数据的修改
    - 当cell在快速滑动时，不加载cell，等到滑动停止了才去加载cell
    - 创建cell的时候就完成布局，在后期设置cell的数据时尽量去添加移除cell内部的控件。
    - 减少离屏渲染的问题。当每个cell都有View同时设置了图片跟切了圆角，那么每个cell都产生离屏渲染，这样对App的性能损耗是很大的。解决办法就是利用贝塞尔曲线绘制出圆角，同时结合CAShapeLayer的使用来实现View的设置图片以及切圆角。

## YTK源码

## VC瘦身
- 使用自定义的View，避免将所有View都在ViewCOntroller的.m文件上进行创建跟addSubview
- 使用MVC设计范式，将关于视图创建的数据以及模型更新的数据抽离倒View层和Model层，避免ViewController过于臃肿
- 或者使用比MVC更高级的设计范式，比如MVP模式或者MVVM模式，将ViewController层的关于网络请求、一些交互逻辑抽离出去，减轻ViewController的负担

## OC中weak的实现
首先会调用objc_initWeak方法，判断弱引用指向的对象是否为nil，是nil的话就会直接返回，不是nil的话进而调用storeWeak方法，在该方法里，通过指向的对象的内存地址确定了对象所在的SideTable，从而获取到对象在的weak_Table，后面的话调用weak_register_no_lock方法，在这个方法里面，首先会根据对象的指针去查找弱引用表里是否有对应的弱引用入口，有的话就直接往弱引用数组里添加弱引用，没有的话为此对象创建一个weak_entry，并添加指向它的弱引用，最后会将这个弱引用入口添加到weak_Table上。


## 讲一下自动释放池
自动释放池其实就是个双向链表，每个链表是一个AutoreleasepoolPage结构体，结构体内有parent和child两个指针来链接上一个链表以及下一个链表，结构体内还有一个next指针指向当前page下一个可以存放autorelease对象地址的位置。

每创建一个自动释放池，就会在池子的首部插入一个哨兵对象，作为当前自动释放池的标记。
当要插入新的autorelease对象，就会先取到当前的page，根据page的next指针是否已经指向page的末尾来判断当前page是否已经满了，满了就创一个新的page，两个page之间利用parent指针和child指针来链接起来，往新的page里插入autorelease对象，没满的话就在获取到的page上通过next指针指向的位置插入autorelease对象的地址，

当要销毁这个自动释放池时，就会从自动释放池中最后一个插入的aurelease对象开始，依次给他们发送一个release消息，直到遇到哨兵对象。

在iOS里对autorelease对象有两种释放方式，一种是系统干预释放，另一种是手动干预释放。
系统干预释放就是程序中的autorelease对象都是由主线程对应的自动释放池管理的。iOS在主线程的RunLoop添加了对即将进入RunLoop和即将进入休眠以及即将退出RunLoop事件进行了监听，当即将进入RunLoop时，就会创建一个自动释放池，当即将进入休眠时，就会销毁自动释放池并创建一个新的自动释放池，当即将退出RunLoop时，就会销毁自动释放池。

手动干预释放就是在手动创建的自动释放池的作用域结束时就会销毁这个自动释放池，释放里面的对象。


## iOS内存分区情况
- 栈区（Stack）
    - 由系统自动分配释放，存放函数的参数，局部变量的值等
    - 栈是向低地址扩展的数据结构，是一块连续的内存区域
- 堆区（Heap）
    - 由程序员分配释放
    - 是向高地址扩展的数据结构，是不连续的内存区域
- 全局区
    - 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域
    - 程序结束后由系统释放
- 常量区
    - 常量字符串就是放在这里的
    - 程序结束后由系统释放
- 代码区
    - 存放函数体的二进制代码

- 栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。是栈顶的地址和栈的最大容量是系统预先规定好的，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数 ) ,如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

## iOS内存管理方式
- Tagged Pointer（小对象）

Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate

Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要 malloc 和 free

在内存读取上有着 3 倍的效率，创建时比以前快 106 倍

objc_msgSend 能识别 Tagged Pointer，比如 NSNumber 的 intValue 方法，直接从指针提取数据

使用 Tagged Pointer 后，指针内存储的数据变成了 Tag + Data，也就是将数据直接存储在了指针中

- NONPOINTER_ISA （指针中存放与该对象内存相关的信息）
优化过的isa指针，并不需要将64个二进制位全部用来存储指针，还保存着关于对象内存相关的信息，比如引用计数，是否引用了散列表，是否被弱引用指向，是否含有关联引用等信息。

- 散列表（引用计数表、弱引用表）
系统会维护一个SideTables，SideTables里面又维护着多个散列表，在IPhone真机上是有8个散列表，其他平台上是有64个散列表。散列表SideTable是一个结构体，里面存放着引用计数表以及弱引用表。

先讲一下引用计数表。
当对象的引用计数比较小时，会放在isa结构体上的extra_rc上，当对象的引用计数超出一定范围时就会存放到引用计数表。
当要对对象的引用计数+1或者-1时，在SideTables上根据对象的内存地址找到它所在的散列表SideTable，在散列表的成员变量引用计数表中根据对象的内存地址取出对象的引用计数，然后进行+1或者-1的操作。

弱引用表
对对象添加弱引用时，首先会在SideTables上根据对象的内存地址取出对应的散列表，在散列表的成员变量weak_Table上根据对象的内存地址判断该对象是否有对应的弱引用入口weak_entry，有的话直接在弱引用入口结构体中管理的弱引用数组添加一个新的弱引用，没有的话就为该对象创建一个弱引用入口，添加弱引用指向，并将这个弱引用入口添加到弱引用表上。

## KVC
KVC - 键值编码 属于一种消息传递方式
KVC设值的工作原理：
- 程序会优先调用属性的set方法，通过setter方法完成设置。
- 如果没有找到属性对应的setter方法，那么KVC机制会先检查类方法accessInstanceVariableDirectly返回的是否是YES，YES则表示可以去查找有无对应的成员变量，返回NO的话，那么就会调用setValue: forUndefineKey:方法，在该方法内部默认是抛出异常的。
- 当可以直接查找成员变量时，会依次按照_key,_isKey,key,isKey的顺序去查找成员变量，有的话就直接赋值，若还是没找到，那么最终还是调用setValue: forUndefineKey:方法，在该方法内部抛出异常。

KVC取值的工作原理：
- 程序会优先查找属性的getter方法。（如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。）
- 若没有对应的getter方法，那么KVC会检查类方法+ (BOOL)accessInstanceVariablesDirectly的返回结果，如果是NO，那么就会执行valueForUndefinedKey方法，默认是抛出异常。
- 如果返回的是YES，那么就会依次按照_key,_isKey,key,isKey的顺序去获取变量的值
- 如果都没获取到值，那么最后还是会调用valueForUndefinedKey方法，抛出异常。

## KVO
KVO的工作机制：
KVO是通过方法交换来实现的。
- 当给目标对象的属性添加KVO监听时，系统会给被观察对象创建一个派生类，被观察对象的isa指针指向派生类，并且会在派生类里重写被观察属性的setter方法
- 当被观察对象的值发生变化时，那么就会调用到派生类的setter方法
- 在setter方法里面会先调用willChangeValueForKey方法
- 然后会给属性赋值
- 赋值完之后再调用didChangeValueForKey方法，在didChangeValueForKey方法里面会调用通知观察者的方法observeValueForKeyPath，通知属性值发生了变化。
- 重写了dealloc方法；在移除KVO观察者后，对象的isa指针由指向派生类到指向原来所属的类

## 通知和代理有什么区别
- 通知是观察者模式，适合一对多的场景
- 代理模式适合一对一的反向传值
- 通知监听方法不能有返回值，代理实现的方法可以有返回值
- 通知的耦合度较低，发布通知时不需要知道监听者是谁，监听者只需要知道通知的名称即可实现监听。

## block和delegate的区别
- delegate运行成本低，block的运行成本高。
    - block出栈需要将使用的数据从栈内存拷贝到堆内存，如果是对象的话就是加计数，使用完或者block置nil后才消除。delegate只是保存了一个对象指针，直接回调，没有额外消耗。就像C的函数指针，只多做了一个查表动作。
- 有多个相关方法。假如每个方法都设置一个 block, 这样会更麻烦。而 delegate 让多个方法分成一组，只需要设置一次，就可以多次回调。当多于 3 个方法时就应该优先采用 delegate。当1，2个回调时，则使用block。
- delegate更安全些，比如: 避免循环引用。使用 block 时稍微不注意就形成循环引用，导致对象释放不了。这种循环引用，一旦出现就比较难检查出来。而 delegate 的方法是分离开的，并不会引用上下文，因此会更安全些。
- delegate回调返回的参数被限制在了 NS 类的范围内，数量也很有限；当对协议定义的方法返回Int，CGFloat等基础类型时，是会报错的。

## 为什么Block用copy关键字
Block在没有使用外部变量时，内存存在全局区，然而，当Block在使用外部变量的时候，内存是存在于栈区，当Block copy之后，是存在堆区的。存在于栈区的特点是对象随时有可能被销毁，一旦销毁再调用的时候，就会造成系统的崩溃。所以Block要用copy关键字。

## iOS 开发中数据持久性有哪几种?
iOS本地数据保存有多种方式,比如NSUserDefaults、归档、文件保存、数据库、CoreData、KeyChain(钥匙串)等多种方式。其中KeyChain(钥匙串)是保存到沙盒范围以外的地方，也就是与沙盒无关。

## keychain
keychain相当于苹果提供的数据库，用来加密保存存储的数据。keychain里面可以存通用密码，互联网密码，证书、密钥及身份信息。
keychain还可以保存应用程序的一些敏感信息，keychain是独立于应用程序的沙盒的，即使删除了应用程序，保存在keychain里的信息还是会存在的。
keychain存储的信息还可以实现多个应用程序一起共享，应用程序沙盒里存储的数据别的应用是无法查看的，但是保存在keychain里的数据是可以共享的，但前提是两个应用程序的Team ID是必须一样的，即得是同一个开发者账号。


## 归档和解档
归档：就是将对象序列化之后存储的过程
解档：对归档的数据进行解码
序列化：将对象的状态信息转换为可以存储或传输的形式的过程

实现归档和解档，对象要遵守NSCoding协议，并且重写 -initWithCoder:（归档） 和 encodeWithCoder:（解档）方法