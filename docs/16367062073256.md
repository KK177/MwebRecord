# 操作系统面试题整理
[TOC]
## 什么是操作系统？
1. 操作系统（OS）是是系统最基本最核心的软件，属于系统软件
2. 操作系统本质上是运行在计算机的软件程序，它控制和管理整个计算机的硬件和软件资源，合理的组织、调度计算机的工作与资源的分配
3. 操作系统的存在屏蔽了硬件层面的复杂性，向用户和应用程序提供了命令接口和程序接口

## 讲一讲用户态和系统态
- 用户态和系统态是处理器的两种状态
- CPU在用户态下，只能执行非特权指令，比如加减乘除这些简单指令；还有用户态运行下的程序可以访问的资源受到限制，只能访问自己程序下的数据
- CPU在系统态下，既能执行特权指令，也能执行非特权指令，特权指令是指用户不能直接调用的指令，比如I/O指令，内存清零等指令；在系统态下运行的程序访问资源不收到限制。
- 我们运行的程序基本上都在用户态运行，如果需要调用系统级别的子功能（如文件管理，进程控制，内存管理等）则需要切换到系统态，进行系统调用。通过系统调用，向操作系统提出请求，由其代为完成。

## 讲一讲系统调用
系统调用是操作系统提供给应用程序的接口，应用程序可以通过系统调用（程序接口）请求获得操作系统的服务；系统调用会使处理器从用户态切换到内核态。
按照系统调用的功能分类，可以分为
1. 设备管理：设备的请求或释放，如视频电话启动摄像头；
2. 文件管理：文件的修改、创建、删除等；
3. 进程控制：进程的创建、撤销、阻塞、唤醒等；
4. 进程通信：完成进程间的消息或信号传递；
5. 内存管理：内存分配（malloc 函数）、回收（free）、地址转换（将逻辑地址转化为物理地址等）

## 程序、进程、线程的基本概念
- 程序：
    - 程序是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。
- 进程
    - 在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程(Process) 的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性（最基本的两个特性）。
    - 为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块(Process Control Block, PCB) 。系统利用PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。
    - 相应地，由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的PCB; 而撤销进程，实质上是撤销进程的PCB 。值得注意的是，进程映像是静态的，进程则是动态的。
    - 引入进程实体的概念后，我们可以把传统操作系统中的进程定义为： “进程是进程实体的运行过程是系统进行资源分配的基本单位。
- 线程
    - 引入进程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。
    - 线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID 、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。

### 程序和进程比较
1. 程序是永存的(除非删除)；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；
2. 程序是静态的观念，进程是动态的观念；
3. 进程具有并发性，而程序没有；
4. 进程是竞争计算机资源的基本单位，程序不是。
5. 进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程同一时间内执行一个程序。
    1. 在Windows下，浏览器一般是一个页面对应一个进程，所以可以理解为一个程序可以对应多个进程。

### 为什么要引入进程
在多道程序同时运行的背景下，进程之间需要共享系统资源，因此会导致各程序在执行过程中出现相互制约的关系，程序的执行会表现出间断性的特征。这些特征都是在程序的执行过程中发生的，是动态的过程，而传统的程序本身是一组指令的集合，是一个静态的概念，无法描述程序在内存中的执行情况，即我们无法从程序的字面上看出它何时执行、何时停顿，也无法看出它与其他执行程序的关系，因此，程序这个静态概念已不能如实反映程序并发执行过程的特征。为了深刻描述程序动态执行过程的性质乃至更好地支持和管理多道程序的并发执行，人们引入了进程的概念。

### 进程是如何解决问题的？
进程把能够识别程序运行态的一些变量存放在PCB中，通过这些变量系统能够更好地了解进程的状况，并在适当时进行进程的切换，以避免一些资源的浪费，甚至划分为更小的调度单位线程来提高系统的并发度。

### 线程与进程的比较
1. 调度。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。
2. 拥有资源。不论是传统操作系统还是设有线程的操作系统，进程都是拥有资源的基本单位，而线程不拥有系统资源（也有一点儿必不可少的资源），但线程可以访问其隶属进程的系统资源。要知道，若线程也是拥有资源的单位，则切换线程就需要较大的时空开销，线程这个概念的提出就没有意义。
3. 并发性。在引入线程的操作系统中，不仅进程之间可以并发执行，而且多个线程之间也可以并发执行，从而使操作系统具有更好的并发性，提高了系统的吞吐量。
4. 系统开销。由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/0 设备等，因此操作系统所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程CPU 环境的保存及新调度到进程CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的干预。
5. 地址空间和其他资源（如打开的文件）。进程的地址空间之间互相独立，同一进程的各线程间共享进程的资源，某进程内的线程对于其他进程不可见。
6. 通信方面。进程间通信(IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性，而线程间可以直接读／写进程数据段（如全局变量）来进行通信。

### 为什么要引入线程？
进程存在着很多缺陷，主要集中在两点：
 (1)进程只能在同一时间干一件事情，如果想同时干两件事或多件事情，进程就无能为力了。 
 (2)进程在执行的过程中如果由于某种原因阻塞了，例如等待输入，整个进程就会挂起，其他与输入无关的工作也必须等待输入结束后才能顺序执行。 
 为了解决上述两点缺陷，引入了线程这个概念。
 
 引入进程的目的是为了更好地使多道程序并发执行，提高资源利用率和系统吞吐量；而引入线程的目的则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。
 
### 线程同步机制
两个或以上的线程并发执行时，可能会访问到共享的关键资源，那么，线程同步就是为了避免关键资源的使用冲突。
实现线程同步有三种方式
- 互斥锁：同一时刻只允许一个线程执行一个关键部分的代码；线程执行关键代码之前先上锁，执行完之后解锁，那么其他线程才有机会执行关键代码。
- 信号量：采用记录型信号量机制；同一时间内可以允许一个或多个线程同时访问共享资源，信号量的大小是可同时访问的资源数的大小；线程访问资源前，先对信号量进行p操作，若此时信号量>=0，那么允许访问，若<0，那么该线程就会加入到阻塞队列中，等待唤醒；访问资源后，对信号量进行V操作。
- 事件：通过通知操作的方式，来实现多线程的同步；当事件触发之后，那么处于等待状态下的线程就会被唤醒，等待被调度。

### 进程的状态
进程的状态主要分为：创建态、就绪态、运行态、阻塞态、撤销态、挂起态、挂起态又分为就绪挂起和阻塞挂起。

### 抢占式进程调度和进程优先级
#### 早期的批处理系统
早期的批处理系统主要有三种进程调度算法，分别是先来先服务FCFS，短作业/进程优先 SJF/SPF，高响应比优先算法HRRN

先来先服务—FCFS
非抢占时的调度算法
![](media/16367062073256/16378094932247.png)

短作业优先—SJF / 短进程优先—SPF
该算法分为抢占式和非抢占式
![](media/16367062073256/16378096011572.png)

高响应比优先—HRRN
非抢占时的调度算法，该算法综合考虑了进程的服务时间以及等待时间
![](media/16367062073256/16378096630213.png)

![](media/16367062073256/16378096907165.png)

#### 适用于交互系统的调度算法
在交互系统中，主要有三种进程调度算法，分别是时间片轮转（RR）算法、优先级调度算法、多级反馈队列调度算法。

时间片轮转 RR
该算法属于抢占式的调度算法
![](media/16367062073256/16378098478204.png)

优先级调度算法
该算法分为抢占式以及非抢占式；非抢占式只能等待进程主动放弃处理机，而抢占式需要在就绪队列发生变化时，检测是否需要抢占。
![](media/16367062073256/16378098881077.png)

对于进程的优先级
![](media/16367062073256/16378100133818.png)

多级反馈队列调度算法
结合了时间片以及优先级的抢占式调度算法。
![](media/16367062073256/16378100728135.png)

三种算法的对比
![](media/16367062073256/16378101265986.png)

#### 进程优先级
对于进程优先级的设置一般遵循三个规则
- 系统级进程 > 用户级进程
- I/O型进程 > 计算型进程
- 交互进程（前台进程） > 非交互进程（后台进程）

### 僵尸进程与孤儿进程
先了解一些基本概念
我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

　　==孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。==

　　==僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。==

#### 危害
僵尸进程：
unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: ==在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放==。 但这样就导致了问题，==如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。==此即为僵尸进程的危害，应当避免。

孤儿进程：
孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。==每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。==这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。==因此孤儿进程并不会有什么危害。==

### 什么是IO多路复用？
IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄（文件句柄相当于文件的唯一标识符，当执行了系统调用语句后，会返回一个文件句柄）；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程。
简单来说，就是多个IO操作共用一个线程。

## 原子操作原理
原子是指不能被进一步分割的最小粒子，而原子操作指的是不可被中断的一个或一系列操作。在多处理器上实现原子操作主要有两种实现
1. 使用总线锁保证原子性
    1. 总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。
2. 使用缓存锁保证原子性
    1. 因为在同一时刻，我们只需要保证对某个内存地址的操作是原子性即可，但是总线锁把CPU和内存之间的通信锁住了，这会造成在锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大。
    2. 由于频繁使用的内存会缓存在处理器的高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。
    3. 缓存锁是基于缓存一致性的，缓存一致性是指当某块CPU对缓存中的数据进行操作了之后，就会通知其他CPU放弃储存在它们内部的缓存，需要从主存中重新读取。
    4. 但是缓存锁有局限性：
        1. 当操作的数据不能被缓存在处理器内部，或操作的数据跨越多个缓存行（缓存行是缓存的最小存储单位），则处理器会调用总线锁
        2. 有些处理器不支持缓存锁。

        
## 临界区、互斥量、信号量、自旋锁和事件的区别和联系以及使用场景
进程或线程同步互斥的控制方法：
1. 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2. 互斥量：为协调共同对一个共享资源的单独访问而设计的，互斥对象只有一个。 
3. 信号量：为控制一个具有有限数量用户资源而设计，只能在进程上下文中使用，适合长时间访问共享资源的情况 
4. 自旋锁：适合短时间访问共享资源的情况，如果锁被长时间持有，等待线程会消耗大量资源 
5. 事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。

==临界区==
1. 保证在某一时刻只有一个线程能访问关键数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问同一临界区，那么在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。
2. 在使用临界区时，一般不允许其运行时间过长，只要进入临界区的线程还没有离开，其他所有试图进入此临界区的线程都会被挂起而进入到等待状态，并会在一定程度上影响程序的运行性能。尤其需要注意的是不要将等待用户输入或是其他一些外界干预的操作包含到临界区。如果进入了临界区却一直没有释放，同样也会引起其他线程的长时间等待。虽然临界区同步速度很快，但却==只能用来同步本进程内的线程，而不可用来同步多个进程中的线程==。

==互斥量==
1. 和临界区有些相似，只有拥有互斥对象(即互斥量)的线程才具有访问共享资源的权限，由于互斥量只有一个，因此就决定了任何情况下此共享资源都不会同时被多个线程所访问。当占据资源的线程在任务处理完任务后应释放占有的的互斥量，以便其他线程在获得该互斥对象后得以访问资源。
2. 使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。 ==互斥量可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。==

==信号量==
1. 信号量对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的PV操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。
2. 创建信号量时即要同时指出允许的最大资源计数和当前可用资源计数。一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就会减1，只要当前可用资源计数是大于0的，就可以发出信号量信号。但是当前可用计数减小到0时则说明当前占用资源的线程数已经达到了所允许的最大数目， 不能在允许其他线程的进入，此时的信号量信号将无法发出。
3. 线程在处理完共享资源后，应在离开的同时将当前可用资源计数加1。在任何时候当前可用资源计数决不可能大于最大资源计数。 
P操作申请资源： 
　　（1）S减1； 
　　（2）若S减1后仍大于等于零，则进程继续执行； 
　　（3）若S减1后小于零，则该进程被阻塞后进入与该信号相对应的队列中，然后转入进程调度。 
V操作释放资源： 
　　（1）S加1； 
　　（2）若相加结果大于零，则进程继续执行； 
　　（3）若相加结果小于等于零，则从该信号的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转入进程调度。 

==自旋锁==
自旋锁的目的是为了保护共享资源，实现线程同步。自旋锁区别于其他锁的地方在于若某线程在未获得锁时将不断的询问（判断）自旋锁保持者是否释放了锁（获取锁操作将自旋在那里，不断地申请获取，直到自旋锁保持者释放了锁），因此比较适用于保持锁时间比较短的情况（CPU一直在空转）。需要注意的是：一个锁只能有一个保持着。 

==事件==
事件对象也可以通过通知操作的方式来保持线程的同步。并且可以实现不同进程中的线程同步操作。

## 死锁
### 死锁、饥饿、死循环的区别
![](media/16367062073256/16378081561154.png)

### 死锁产生的四个必要条件
![](media/16367062073256/16378081940273.png)

### 什么时候会发生死锁？
![](media/16367062073256/16378083011307.png)

### 死锁的处理策略
![](media/16367062073256/16378083159229.png)

#### 预防死锁
① 破坏互斥条件
![](media/16367062073256/16378084050210.png)
② 破坏不可剥夺条件
![](media/16367062073256/16378084285939.png)
③ 破坏请求和保持条件
![](media/16367062073256/16378084612488.png)
④ 破坏循环等待条件
![](media/16367062073256/16378084850761.png)

#### 避免死锁
系统在分配资源时利用银行家算法来决定是否允许将资源分配出去。
![](media/16367062073256/16378085840281.png)

#### 死锁的检测和解除
![](media/16367062073256/16378086258879.png)
① 死锁的检测
利用资源分配图来进行死锁的检测；
在资源分配图中，如果可以消除图中的所有分配资源的边，那么证明无死锁发生。
![](media/16367062073256/16378086537638.png)

② 死锁的解除
![](media/16367062073256/16378087847713.png)

