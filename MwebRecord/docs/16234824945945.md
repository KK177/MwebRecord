# 算法

[TOC]

## 基本操作

- 一个算法中的基本操作：通常是算法最内层循环中最费时的操作

- 将每一次循环都要做的操作 作为 `基本操作`

## 三种符号

## 利用极限比较增长次数

## 基本的效率模型

- 1 < logn < n < nlogn < n^2 < n^3 < 2^n < n!

## 利用递推式算出基本操作执行次数

## 选择排序

- 每一次循环先扫描整个列表，找出最小元素，然后跟第一个交换位置，然后继续扫描，继续交换
- 复杂度n^2

## 冒泡排序

- 不断比较相邻元素，然后将最大的元素逐渐交换到最后一个位置，然后继续循环，将第二大元素交换到倒数第二个位置，不断循环，直到结束
- 复杂度n^2



## 深度优先（DFS）

- 类似于树的`先序遍历`



## 广度优先（BFS）

- 类似于树的层序遍历

## 最近对问题

- 分治法 

  > 分分成两半，左边算出最近的两点，右边也算出最近的两点，然后在这四点里面找出最近的两点

## 合并成一个有序表，而且最坏情况下的复杂度为O(log^2 r)

- 其中一个有序表待插入，另外一个有序表利用二分查找查找要插入元素的位置（复杂度为logr），然后遍历一个有序表的长度

## 拓扑排序

- 任何一个有向图，在图中任意选取一个入度为0的顶点，并输出
- 删除该顶点及其所引出的弧
- 重复以上两步，直到图中不存在入度为0的顶点，此时，如果图中所有顶点均已输出，则输出序列为拓扑序列，否则，图中存在回路，拓扑排序失败

## 合并排序

- 复杂度 nlogn

## 快速排序

- 平均情况下复杂度n(logn)

## T(n) = 2T(n/2) + o(n) 复杂度为(nlogn)

## T(n) = 4T(n/2) + o(n) 复杂度为(n^2)

## 堆和堆排序

- 小顶堆——堆中所有非叶子结点均不大于其左右孩子结点
- 大顶堆——堆中所有非叶子结点均不小于其左右孩子结点
- 堆排序复杂度 nlogn

## 堆中插入元素

- 堆的插入操作是将插入元素加到堆尾，然后进行筛选
- 复杂度logn

## 删除堆顶结点

- 用堆尾结点代替堆顶结点，然后删除对堆顶结点进行筛选
- 复杂度logn

## 建堆

- 元素插入堆之后，对编号为n/2.n/2-1...1的元素进行筛选
- 复杂度n

## 霍纳法则

p(x) = 2x^4 - x^3 - 3x^2 + x - 5

转变为

p(x) = x(x(x(2x-1)+3)+1)  + 5

## 动态规划

- 背包问题

## Warshall算法

- 用于计算有向图的传递闭包
- 给定图的顶点之间是否存在着任意长度的有向路径。这种矩阵，称为有向图的传递闭包

## Floyd算法

- 计算最短路径的算法

## Prim算法

- 不断合并结点

## Kruskal算法

- 不断地找权重最小的边

## 哈夫曼树及编码

- 根据0101编码