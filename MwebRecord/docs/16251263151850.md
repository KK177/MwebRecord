## 计组冲刺笔记📒
### 第二章
- 对于真值0，原码和反码对真值+0和-0都有两种不同的表示，而补码和反码对真值+0和-0只有一种表示形式

- 规格化浮点数，对于原码必须满足0.1xxxxx，对于补码必须满足1.0xxxxxxx，对于正的尾数要求范围为 1/2<= M < 1 ，对于补的尾数要求范围为 -1<= M < -1/2

- 移码：就是在真值X的基础上加上偏置值，对于8位机器字长，如果题目没有给出偏置值，那么偏置值就是2^7

- 机器字长：机器字长是指参与运算的数的基本位数，它是由加法器、寄存器的位数决定的，所以机器字长一般等于内部寄存器的大小。字长标志着精度，字长越长，计算的精度就越高。

- IEEE 754标准：
    - 短浮点数：总位数是32位，阶码是8位。
    >  表现格式为：数符（1位）：阶码（移码-8位）：尾数（原码-23位），偏置值为127，由于尾数是规格化浮点数，因此最高位1是隐藏的，所以实际能表示的尾数是24位。
    - 长浮点数：总位数是64位，阶码是11位
    > 表现格式为：数符（1位）；阶码（移码-11位）；尾数（原码-52位），偏置值为1023

- 8421码：不能表示的6位是 1010～1111

- 余3码：不能表示的6位是 0000～0010 和 1101～1111

- 2421码：不能表示的6位是：0101～1010

- 汉明校验码：首先利用 公式 2^(K-1) <= K+N+1 计算出K位校验码的值，然后利用2^(i-1)来计算出每个校验码Pi的位置，然后根据位置的二进制表示算出Pi的值，最后得出汉明校验码。

- 循环冗余码CRC：首先先写出多项式（n位），然后在待传送的信息后面加上n-1位的0得出数A，然后用数A / 多项式，求出余数，再把余数替换到一开始在信息位后面的0.
  校验：将循环冗余码 / 多项式 ，如果最后余数全0，那就表示信息没有出错。
  
### 第三章
- 双操作数的零地址指令的操作数 来自 堆栈的栈顶和次栈顶

- 单操作数的最大指令条数：上一个指令剩余的状态 X 当前指令能表示的状态，无操作数的算法类似

- 间接寻址的指令格式中有一位是状态字

- 转移指令的标志符是 JMP

- 转子指令的标志符是 CALL

- 返回指令的标志符是 RET

- 返回地址是转子指令的下一条指令的地址，保存返回地址的方法有多种：
  1.用子程序的第一个字单元存放返回地址。子程序从第二个字单元开始执行。这种方法可以实现多重转子，但不能实现递归循环，因为子程序的第一个字单元一直被破坏。
  2.用寄存器存放返回地址。可是实现子程序的递归循环。
  3.用堆栈保存返回地址。可以用于实现多重转子和子程序递归。
  
### 第四章
- 加法器的设计

- 变形补码：双符号位补码。最后的运算结果，双符号位若为01，那就是发生了正溢，如果是10，那就是发生了负溢。

- 原码一位乘法 x * y 
    首先求出 ｜x｜ 和 ｜y｜，｜y｜不带符号位的放入寄存器中，根据|y|中的每一位来判断是加 |x| ，还是加0，加完之后，要进行右移，直到把｜y｜中的值逼出去。
    
- 补码一位乘法 x * y
    首先求出x的补码，-x的补码和y的补码，在y的补码那添加一个辅助位来确定加的数 
    
- 原码除法- 恢复余数法 x / y
    首先先求出｜y｜的补码，和-｜y｜的补码。首先先用｜x｜ + -｜y｜的补码，看结果是正的还是负数，如果是正的，那就商1，然后将结果左移，继续 + -｜y｜的补码，如果是负的，那就商0，先将结果加上 ｜y｜的补码，然后再左移，再重新+ -｜y｜的补码。如果最后余数是负的，那还要加上｜y｜的补码。
    
- 原码除法- 不恢复余数法（加减交替法）
    首先先求出｜y｜的补码，和-｜y｜的补码。首先先用｜x｜ + -｜y｜的补码，看结果是正的还是负数，如果是正的，那就商1，然后将结果左移，继续 + -｜y｜的补码，如果是负的，那就商0，先将结果左移，然后加上｜y｜的补码。如果最后余数是负的，那还要加上｜1y｜的补码。判断运算结束的标志是：y一共有n位，那么左移n-1位就运算结束。如果最后余数是负的，那么还要加上｜y｜的补码。  
        
- 补码除法-加减交替法 x/y
    首先先求出x的补码和y的补码，第一步：先看x和y是否同符号，如果同号，就-y（加上[-y]的补码），如果异号，那就加上y的补码，然后观察余数，如果余数和y同符号，那就商1，然后左移，再+【-y】的补码，如果余数和y异号，那么就先商0，左移，再加【y】的补码。判断运算结束的标志是：y一共有n位，那么左移n-1位就运算结束，而且商的最后必定商1！
    
- 浮点数运算
    1.对阶（小阶向大阶靠齐）
    2.尾数相加/相减
    3.规格化
    4.判溢出
    一般判溢出都是在于：阶码部分，尾数溢出可以通过左右规来调整。
    
- ALU
    
### 第五章
- 主存通常由存储体、地址译码驱动电路、I/O和读写电路组成。
- 存储体是主存储器的核心，程序和数据都存放在存储体中。
- 地址译码驱动电路实际上包含译码器和驱动器两部分。译码器将地址总线输入的地址码转换成与之对应的译码输出线上的有效电平。以表示选中了某一个存储单元，然后由驱动器提供驱动电流去驱动相应的读写电路，完成对被选中存储单元的读写操作。

- 存储单元是CPU对主存访问操作的最小存储单元。

- 主存容量：主存容量：64K X 16，表示它由64K个存储单元，每个存储单元的字长为16位。

- 动态RAM的刷新
    刷新通常是以存储体矩阵中的一行为单位进行的。
  刷新方式有：集中式、分散式、异步式。
  集中式：读写操作时不受刷新工作的影响，因此系统的存取速度比较高。主要缺点是在集中刷新期间必须停止读写，这一段时间称为“死区”。
  分散式：把刷新操作分散到每个存取周期内进行。不存在“死区”。
  异步式：就是上面两者的综合。
  
- 字扩展、位扩展、字和位扩展。

### 第六章
 
### 第七章
- 总线带宽公式
    B = W * F / N
    B是总线带宽，W是数据总线宽度，F是总线的时钟频率，N是完成一次数据传送所需要的时钟周期数。
    
- 总线仲裁机构
    总线是由多个设备和部件共享的，为了保证同一时刻只有一个申请者使用总线，总线控制机构中设置有总线判优和仲裁控制逻辑，即按照一定的优点次序来决定哪个部件首先使用总线，只有获得总线使用权的部件才能开始传送数据。总线判优按其仲裁控制机构的设置可分为集中式控制和分布式控制。
    集中式控制有链式查询方式、定时器查询方式、和独立请求方式。
    
- 总线定时控制方式
    总线的定时控制方式一般分为同步方式和异步方式。
    同步定时方式：是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。
    
    异步定时方式：异步定时方式也称为应答方式。在这种方式下，没有公用的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手🤝”信号来实现定时控制。
    
    
### 第八章
- 存储面、磁道、扇区。

- 磁盘的数据传输率；一个磁道的容量 / 旋转一圈所需要的时间。

- 道密度：沿着磁盘半径方向上单位长度上的磁道数。

- 位密度：磁道单位长度上记录的二进制代码数。

- 寻址命令中表示磁盘地址：驱动器号；圆柱面号；盘面号；扇区号。

- 平均等待时间：旋转半圈所需要的时间。

- 字符发生器（字符库）里面存放的是字符点阵，缓存里面放的是字符的ASCII码

- 缓存容量：不考虑显示属性 = 分辨率，考虑显示属性 = 分辨率 * 2

- 屏幕显示位置自左至右，从上到下，相应地，缓存地址从低到高，每个地址码对应一个字符的显示位置。

- 设置四个计数器以控制缓存访问与屏幕扫描之间的同步。
    1.点计数器：字符窗口的列
    2.字计数器：分辨率的列 + 18
    3.行计数器：字符窗口的行
    4.排计数器：分辨率的行 + 1
    
- 主振频率 = 场频 * 点计数器 * 字计数器 * 行计数器 * 排计数器
    
### 第9章
- 主设和外设之间的信息传送控制方式有四种：程序查询方式、程序中断方式、直接存储器存取（DMA）方式、I/O通道控制方式。
    程序查询方式：这种方式控制简单，但外设和主机不能同时工作，各外设之间也不能同时工作，系统效率很低。因此，仅适用于外设的数目不多、对I/O处理的实时要求没那么高、CPU的操作任务比较单一且不很忙的情况。
    程序中断方式适用于中、低速外设。
    DMA方式适用于高速外设。
    I/O通道控制方式适用于多种类型的外设。
    
- 计算机系统的最大I/O传输速率 = 选择通道速率 * 个数 + 字节多路通道速率 